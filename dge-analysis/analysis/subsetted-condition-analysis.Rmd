---
title: "Subsetted Differential Gene Expression (DGE) Analysis"
output:
  workflowr::wflow_html:
    toc: true
    toc_depth: 3
    toc_float: true
    code_folding: hide
editor_options:
  chunk_output_type: console
---

```{r, setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## Load libraries

Ensure you have followed instructions in the readme on activating the renv environment.

```{r, load libraries, warning = FALSE, message = FALSE}
library(tidyverse) # Available via CRAN
library(DESeq2) # Available via Bioconductor
library(RColorBrewer) # Available via CRAN
library(pheatmap) # Available via CRAN
library(genefilter) # Available via Bioconductor
library(limma) # Available via Bioconductor
library(gprofiler2) # Available via CRAN
library(biomaRt) # Available via Bioconductor
library(plotly) # Available via CRAN
library(ggpubr) # Available via CRAN
library(rmarkdown) # Available via CRAN
library(clusterProfiler) # Available via Bioconductor
library(org.Hs.eg.db) # Available via Bioconductor
library(ggrepel) # Available via CRAN
library(ReactomePA) # Available via Bioconductor
library(mygene) # Available via Bioconductor
library(DOSE) # Available via Bioconductor
library(enrichR) # Available via Bioconductor
library(STRINGdb) # Available via Bioconductor
library(EnhancedVolcano)
library(ComplexHeatmap)
```

```{r, include=FALSE}
# Load custom functions
source("code/helpers.R", local = knitr::knit_global())
```

## Data Import

We will be importing counts data from the star-salmon pipeline and our metadata 
for the project which is hosted on Box. This also ensures data is properly ordered by sample id.

```{r, import data}
# Import counts and metadata
sample_metadata <- read_csv("data/Metadata_2024_11_20.csv")
row.names(sample_metadata) <- sample_metadata$ID
counts <- read_tsv("data/star-salmon/salmon_merged_gene_counts_length_scaled.tsv")

# Import variants of interest
genes_of_interest <- read_csv("data/Prioritized_Genes_From_WGS_2025_06_18.csv")
genes_of_interest <- unique(genes_of_interest$Genes)
genes_of_interest <- genes_of_interest[!is.na(genes_of_interest)]

# Use first column (gene_id) for row names
counts <- data.frame(counts, row.names = 1, check.names = FALSE)
counts$Ensembl_ID <- row.names(counts)
drop <- c("Ensembl_ID", "gene_name")
gene_info <- counts[, drop]
counts <- counts[, !(names(counts) %in% drop)] # remove both columns

# What gene (based on variants samples have) is this analysis based on
analysis_name <- "subsetted"
outpath_var <- paste0(analysis_name, "-analysis")

# Check that data is ordered properly
sample_metadata <- check_order(sample_metadata = sample_metadata, counts = counts)

genes_biomart <- retrieve_gene_info(values = gene_info$Ensembl_ID, filters = "ensembl_gene_id_version")
```

## DESeq2 Analysis

```{r, start analysis}
sample_metadata$Family <- factor(sample_metadata$Family)
sample_metadata$Affected <- factor(sample_metadata$Affected)
sample_metadata$Batch <- factor(sample_metadata$Batch)
sample_metadata$Sex <- factor(sample_metadata$Sex)
sample_metadata$Ancestry <- factor(sample_metadata$Ancestry)
sample_metadata$Category <- factor(sample_metadata$Category)
sample_metadata$Subgroup <- factor(sample_metadata$Subgroup)

# Account for Batch and Affected Status
dds <- DESeqDataSetFromMatrix(
  countData = round(counts), colData = sample_metadata,
  design = ~ Batch + Affected
)

# Pre-filtering: Keep only rows that have at least 10 reads total
keep <- rowSums(counts(dds)) >= 50
dds <- dds[keep, ]

# Remove samples from families with multiple samples
# View Excluded_Samples.csv to learn why these were excluded
remove_multiple_fam <- c("8", "12", "19", "21", "23", "27")

# Save excluded/removed samples
# Code is commented out since this is for 1 time usage
# excluded_samples_df <- filter(sample_metadata,
#                        ID %in% remove_multiple_fam)
# write.csv(excluded_samples_df, "data/Excluded_Samples.csv")

# Create a logical vector to index the columns you want to keep
kept_fam_members <- !(colnames(dds) %in% remove_multiple_fam)
dds <- dds[, kept_fam_members]

# Run DESeq function
dds <- DESeq(dds)

# Normalize gene counts for differences in seq. depth/global differences
counts_norm <- counts(dds, normalized = TRUE)
```

### Data transformation

Perform count data transformation by variance stabilizing transformation (vst) on normalized counts.

```{r, vsd}
vsd <- vst(dds, blind = FALSE)
```

### Batch correction with limma

This code performs batch effect correction on variance-stabilized transformed (VST) counts using the Limma package. The corrected counts are then saved and incorporated into the VST object for downstream analysis.

```{r, limma}
# Extract VST counts from the DESeq2 object
counts_vst <- assay(vsd)

# Save the VST counts to a CSV file
write.csv(counts_vst, file = "output/publication-analysis/counts_vst_subsetted.csv")

# Create a model matrix with Batch and Affected as covariates
mm <- model.matrix(~ Batch + Affected, colData(vsd))

# Remove batch effects using the Limma package
counts_vst_limma <- limma::removeBatchEffect(counts_vst,
  batch = vsd$Batch,
  design = mm
)

# Save the batch-effect corrected counts to a CSV file
write.csv(counts_vst_limma, file = "output/publication-analysis/counts_vst_limma_subsetted.csv")

# Replace the VST counts in the DESeq2 object with the batch-effect corrected counts
vsd_limma <- vsd
assay(vsd_limma) <- counts_vst_limma
```

### Data Visualization

#### Sample distances heatmap

This code calculates sample-to-sample distances from the batch-effect corrected VST data, organizes the distances into a matrix, and visualizes the results as a heatmap for quality control.

```{r, sample-dist-heatmap}
# Compute sample-to-sample distances using the corrected VST data
sample_dists_all <- dist(t(assay(vsd_limma)))

# Convert the distance object to a matrix for visualization
sample_dist_matrix_all <- as.matrix(sample_dists_all)

# Set row and column names for the distance matrix using metadata
rownames(sample_dist_matrix_all) <- paste(vsd_limma$Batch, vsd_limma$Affected, sep = " | ")
colnames(sample_dist_matrix_all) <- paste(vsd_limma$ID, vsd_limma$Affected, sep = " | ")

# Define a color palette for the heatmap
colors <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)

# Plot the heatmap of sample distances with hierarchical clustering
pheatmap(sample_dist_matrix_all,
  clustering_distance_rows = sample_dists_all,
  clustering_distance_cols = sample_dists_all,
  col = colors
)
```

#### Principal Components Analysis & Visualization

This code prepares data for PCA analysis, computes principal components using batch-effect corrected VST data, and generates a PCA plot to visualize sample clustering based on specified metadata variables.

```{r, principal-components-analysis-all}
# Prepare PCA data from the corrected VST data
# intgroup specifies the metadata variables to include in the PCA
pca_results <- prepare_pca_data(vsd_data = vsd_limma, intgroup = c("Batch", "Affected", "Sex"))

# Generate a PCA plot with metadata-based coloring, filling, and shaping
pca_plot <- generate_pca_plot(
  pca_data = pca_results$pca_data,
  percent_var = pca_results$percent_var,
  colour = "Affected", # Color by affected status
  fill = "Sex", # Fill by sex
  shape = "Batch" # Shape by batch
)

# Display the PCA plot
print(pca_plot)
```

The below PCA plot highlights overall categories, affected status, and batch information for each sample.
```{r, principal-components-analysis-category}
# Prepare PCA data
pca_results <- prepare_pca_data(
  vsd_data = vsd_limma,
  intgroup = c("Batch", "Affected", "Category")
)

# Generate PCA plot
pca_plot <- generate_pca_plot(
  pca_data = pca_results$pca_data,
  percent_var = pca_results$percent_var,
  colour = "Category", fill = "Affected", shape = "Batch"
)

# Display the plot
pca_plot
```

#### Heatmaps of Genes with Highest Variance

```{r, heatmap-colors, out.height="570px", out.width ="800px"}
# Specify annotation colors by columns
# Use RColorBrewer::brewer.pal(n=10, name="Set1")
category_colors <- c(
  ENE        = "#3C8031",  # Energy Production and Metabolism (green)
  STR        = "#1F57C3",  # Muscle Structure and Stability (blue)
  RBC        = "#C9302C",  # RBC Membrane Integrity (red)
  SOL        = "#9B2FAE",  # Solute Transport and Ion Homeostasis (purple)
  IMM        = "#FFB000",  # IMM (assigned amber-gold)
  Unaffected = "#808080"   # Neutral gray
)

ann_colors <- list(
  Batch = c(B1 = "#c38b1f", B2 = "#c31f57", B3 = "#1fc38b"),
  Affected = c(Affected = "#800000", Unaffected = "#010080"),
  Category = category_colors
)
```

This is a heatmap of the top 50 genes with the highest variance across samples

```{r, top50-heatmap-batch-combined, out.height="570px", out.width ="800px"}
# Parameters for the function
annotation_columns <- c("Batch", "Affected", "Category")
annotation_colors <- ann_colors # Predefined annotation colors

# Generate the heatmap for the top 50 variable genes
generate_top_variable_genes_heatmap(
  vsd_data = vsd_limma,
  gene_info = gene_info,
  annotation_columns = annotation_columns,
  annotation_colors = annotation_colors,
  top_n = 50
)
```

### Comparison/Contrast of Affected_Affected_vs_Unaffected 

This code performs differential expression analysis between affected and unaffected samples, processes and filters the results, and summarizes the findings based on adjusted p-value and log2 fold change thresholds.

```{r}
# Perform differential expression analysis for affected vs. unaffected samples
res_aff_vs_unaff_sub <- results(dds, contrast = c("Affected", "Affected", "Unaffected"))

# Process and save the results to a CSV file
res_aff_vs_unaff_df_sub <- process_and_save_results(
  res_aff_vs_unaff_sub,
  "output/publication-analysis/res_aff_vs_unaff_sub.csv"
)

# Arrange the results by adjusted p-value
res_aff_vs_unaff_df_sub <- arrange(res_aff_vs_unaff_df_sub, padj)

# Filter results with adjusted p-value < 0.05
res_aff_vs_unaff_df_05_sub <- subset(res_aff_vs_unaff_df_sub, padj < 0.05)

# Filter results with adjusted p-value < 0.1
res_aff_vs_unaff_df_1_sub <- subset(res_aff_vs_unaff_df_sub, padj < 0.1)

# Further filter results with |log2 fold change| >= 1 and adjusted p-value < 0.1
res_aff_vs_unaff_df_padj1_lfc1_sub <- subset(res_aff_vs_unaff_df_1_sub, log2FoldChange >= 1 | log2FoldChange <= -1)

# Further filter results with |log2 fold change| >= 1 and adjusted p-value < 0.05
res_aff_vs_unaff_df_padj05_lfc1_sub <- subset(res_aff_vs_unaff_df_05_sub, log2FoldChange >= 1 | log2FoldChange <= -1)

# Summarize the differential expression results
summary(res_aff_vs_unaff_sub)
```

#### Heatmap of Significant Genes

This code generates a heatmap for significantly differentially expressed genes (DEGs) with an adjusted `p-value < 0.1` and `|log2 fold change| ≥ 1`. It uses metadata annotations for grouping and color-coding.

```{r, significant-genes-deseq-subsetted-category-lfc1, out.height="570px", out.width ="800px"}
# Parameters for the function
annotation_columns <- c("Affected", "Category")
annotation_colors <- ann_colors # Predefined annotation colors
output_file <- "output/publication-analysis/Supplemental Figure 4. DEGs (Padj < 0.1).png"

# Generate the heatmap for significant genes
generate_significant_genes_heatmap(
  vsd_data = vsd_limma,
  res_data = res_aff_vs_unaff_df_padj1_lfc1_sub, # Significant genes
  gene_info = gene_info,
  annotation_columns = annotation_columns,
  annotation_colors = annotation_colors,
  output_file = output_file
)
```

This code generates a heatmap for significantly differentially expressed genes (DEGs) with an adjusted `p-value < 0.05` and `|log2 fold change| ≥ 1`. It uses metadata annotations for grouping and color-coding.

```{r, significant-genes-deseq-subsetted-category-padj05-lfc1, out.height="570px", out.width ="800px"}
# Parameters for the function
annotation_columns <- c("Affected", "Category")
annotation_colors <- ann_colors # Predefined annotation colors
output_file <- "output/publication-analysis/Supplemental Figure 4. Significant DEGs (Padj < 0.05).png"

# Generate the heatmap for significant genes
generate_significant_genes_heatmap(
  vsd_data = vsd_limma,
  res_data = res_aff_vs_unaff_df_padj05_lfc1_sub, # Significant genes
  gene_info = gene_info,
  annotation_columns = annotation_columns,
  annotation_colors = annotation_colors,
  output_file = output_file
)
```

This code integrates gene annotations into the differential expression results using Ensembl IDs and reorders the data by adjusted p-values for downstream analysis.

```{r, all-genes-list-subsetted}
# Extract relevant columns from the gene information data
gb_df <- genes_biomart[, c(1, ncol(genes_biomart))]

# Add Ensembl IDs to the DEG results
res_aff_vs_unaff_df_sub_genename <- res_aff_vs_unaff_df_sub
res_aff_vs_unaff_df_sub_genename$Ensembl_ID <- row.names(res_aff_vs_unaff_df_sub)

# Merge DEG results with gene information based on Ensembl IDs
res_aff_vs_unaff_df_sub_genename <- merge(
  x = res_aff_vs_unaff_df_sub_genename,
  y = gene_info,
  by.x = "Ensembl_ID",
  by.y = "Ensembl_ID",
  all.x = TRUE
)

# Reorganize columns to place gene annotations first
res_aff_vs_unaff_df_sub_genename <- res_aff_vs_unaff_df_sub_genename[, c(
  dim(res_aff_vs_unaff_df_sub_genename)[2],
  1:(dim(res_aff_vs_unaff_df_sub_genename)[2] - 1)
)]

# Order the DEG results by adjusted p-value
res_aff_vs_unaff_df_sub_genename <- res_aff_vs_unaff_df_sub_genename[
  order(res_aff_vs_unaff_df_sub_genename[, "padj"]),
]

# Save the updated results with gene annotations to a CSV file
write.csv(
  res_aff_vs_unaff_df_sub_genename,
  file = "output/publication-analysis/res_aff_vs_unaff_df_sub_genename.csv"
)
```

#### Volcano Plot

This code generates a volcano plot to visualize the distribution of differentially expressed genes (DEGs) and highlights selected genes and applying thresholds for significance and fold change.

```{r, volcano-plot, out.height="1000px", out.width ="1600px"}
# Parameters for the function
res_data <- res_aff_vs_unaff_df_sub_genename
gene_labels <- "gene_name"
x_col <- "log2FoldChange"
y_col <- "padj"
select_genes <- c("SLC4A10", "SNTG2", "KCNQ5", "DEFA1", "CD248", "POLR3G", "ZNF683")
xlab_text <- bquote(~ Log[2] ~ "fold change")
ylab_text <- bquote(~ Log[10] ~ "padj")
xlim_range <- c(-25, 25)
ylim_range <- c(0, 7)
output_file <- "output/publication-analysis/subsetted-analysis-volcano-plot.png"

# Generate and save the volcano plot
generate_volcano_plot(
  res_data = res_data, gene_labels = gene_labels, x_col = x_col,
  y_col = y_col, select_genes = select_genes, xlab_text = xlab_text,
  ylab_text = ylab_text, p_cutoff = 0.05, fc_cutoff = 1.0,
  xlim_range = xlim_range, ylim_range = ylim_range,
  output_file = output_file
)
```

This code subsets differentially expressed genes (DEGs) by significance thresholds, orders them by adjusted p-values, and saves the results to separate CSV files for further analysis and reporting.

```{r, significant-with-genename-padj-lfc}
res_aff_vs_unaff_df_genename_05 <- subset(res_aff_vs_unaff_df_sub_genename, padj < 0.05)
res_aff_vs_unaff_df_genename_05 <- res_aff_vs_unaff_df_genename_05[order(res_aff_vs_unaff_df_genename_05$padj), ]
write.csv(res_aff_vs_unaff_df_genename_05, file = "output/publication-analysis/res_aff_vs_unaff_df_sub_genename_05.csv")

res_aff_vs_unaff_df_genename_padj05_lfc1 <- subset(res_aff_vs_unaff_df_genename_05, log2FoldChange >= 1 | log2FoldChange <= -1)
res_aff_vs_unaff_df_genename_padj05_lfc1 <- res_aff_vs_unaff_df_genename_padj05_lfc1[order(res_aff_vs_unaff_df_genename_padj05_lfc1$padj), ]
write.csv(res_aff_vs_unaff_df_genename_padj05_lfc1, file = "output/publication-analysis/Supplemental Table 5. Significant Differentially Expressed Genes.csv", row.names = FALSE)

res_aff_vs_unaff_df_genename_1 <- subset(res_aff_vs_unaff_df_sub_genename, padj < 0.1)
res_aff_vs_unaff_df_genename_1 <- res_aff_vs_unaff_df_genename_1[order(res_aff_vs_unaff_df_genename_1$padj), ]
write.csv(res_aff_vs_unaff_df_genename_1, file = "output/publication-analysis/res_aff_vs_unaff_df_sub_genename_padj1.csv")

res_aff_vs_unaff_df_genename_padj1_lfc1 <- subset(res_aff_vs_unaff_df_genename_1, log2FoldChange >= 1 | log2FoldChange <= -1)
res_aff_vs_unaff_df_genename_padj1_lfc1 <- res_aff_vs_unaff_df_genename_padj1_lfc1[order(res_aff_vs_unaff_df_genename_padj1_lfc1$padj), ]
write.csv(res_aff_vs_unaff_df_genename_padj1_lfc1, file = "output/publication-analysis/res_aff_vs_unaff_df_sub_genename_padj1_lfc1.csv")
```

This code queries gene symbols from significant DEGs (padj < 0.05) against the mygene.info database to retrieve detailed annotations, ensuring unique results for each gene.

```{r, padj-gene-info-subsetted}
# Extract gene symbols from significant DEGs (Padj < 0.05)
genes <- res_aff_vs_unaff_df_genename_05$gene_name

# Query gene information from mygene.info
# Retrieve gene symbol, name, and summary fields for human species
my_gene_data <- queryMany(
  genes,
  scopes = "symbol",
  fields = c("symbol", "name", "summary"),
  species = "human"
)

# Convert the results to a data frame and ensure unique entries for each query
my_gene_data_unique <- as.data.frame(my_gene_data) %>%
  dplyr::distinct(query, .keep_all = TRUE)
```

#### MA Plot and Significant Gene Analysis

This code generates an MA plot to visualize the differential expression results, identifies significant genes, combines these with detailed gene annotations, and saves the results to CSV files.

```{r, maplot-subsetted-samples}
filtered_gene_names <- res_aff_vs_unaff_df_sub_genename$gene_name[!grepl("^ENS", res_aff_vs_unaff_df_sub_genename$gene_name)]
# Select specific genes to show
# set top = 0, then specify genes using label.select argument
# Generate the MA plot
maplot <- generate_ma_plot(
  data = res_aff_vs_unaff_df_sub,
  genenames = as.vector(res_aff_vs_unaff_df_sub_genename$gene_name),
  main_title = "Affected vs Unaffected MA Plot",
  top_genes = 30
)
maplot

significant_data <- maplot$data %>%
  filter(grepl("Up|Down", sig)) %>%
  mutate(direction = ifelse(grepl("Up", sig), "Up", "Down")) %>%
  dplyr::select(-sig) # This removes the 'sig' column

# Combine DataFrames based on matching 'query' in my_gene_data_unique to 'gene' in significant_data
combined_data <- inner_join(my_gene_data_unique, significant_data, by = c("query" = "name"))

combined_data <- combined_data %>%
  dplyr::select(-notfound, -X_id, -X_score) %>%
  rename(gene = query)

paged_table(as.data.frame(significant_data), options = list(rows.print = 30))
# Save significant genes
write.csv(significant_data, file = "output/publication-analysis/res_aff_vs_unaff_significant_subsetted_samples.csv", row.names = FALSE)

# Save significant genes
write.csv(combined_data, file = "output/publication-analysis/res_aff_vs_unaff_significant_subsetted_mygene.csv", row.names = FALSE)
```

##### Expression of Candidate Genes

Below is a table of expression of the genes identified during our WGS analysis.

```{r, genes-of-interest-table-subsetted}
# Subset gene_info using genes of interest
subset_gene_info <- gene_info[gene_info$gene_name %in% genes_of_interest, ]

filtered_by_interest <- filter(res_aff_vs_unaff_df_sub_genename, Ensembl_ID %in% subset_gene_info$Ensembl_ID)

# Filtering the dataframe by row names
filtered_counts <- counts[row.names(counts) %in% subset_gene_info$Ensembl_ID, ]

# Match and update row names
matching_indices <- match(rownames(filtered_counts), subset_gene_info$Ensembl_ID)

# Update row names based on matching_column values from metadata
rownames(filtered_counts) <- subset_gene_info$gene_name[matching_indices]

missing_genes <- setdiff(subset_gene_info$Ensembl_ID, filtered_by_interest$Ensembl_ID)

corresponding_gene_names <- subset_gene_info$gene_name[subset_gene_info$Ensembl_ID %in% missing_genes]

# Add this to get the counts and assign gene names as rownames
missing_gene_counts <- counts[rownames(counts) %in% missing_genes, ]

missing_gene_map <- subset_gene_info[match(rownames(missing_gene_counts), subset_gene_info$Ensembl_ID), "gene_name"]

rownames(missing_gene_counts) <- missing_gene_map

# Save Missing Genes As CSV
write.csv(missing_gene_counts,
          file = "output/publication-analysis/missing_genes_interest_counts.csv")

paged_table(filtered_by_interest, options = list(rows.print = 15))

paged_table(filtered_counts, options = list(rows.print = 15))
```

#### STRINGdb Network Visualization

This code visualizes a protein-protein interaction network for significant DEGs using STRINGdb. It includes mapping DEGs, adding differential expression color codes, and generating a network plot.

```{r, stringdb-network-significant}
library(igraph)

library(STRINGdb)
library(igraph)

# STRINGdb setup
string_db <- STRINGdb$new(version = "11.5", species = 9606,
                          score_threshold = 100, network_type = "full",
                          input_directory = "")

# Combine DEGs and genes of interest
all_genes <- unique(c(significant_data$name, genes_of_interest))

# Map to STRING IDs
mapped_all <- string_db$map(data.frame(name = all_genes), "name", removeUnmappedRows = TRUE)

# Label type
mapped_all$type <- ifelse(mapped_all$name %in% significant_data$name, "DEG", "variant")

# Merge logFC from DEGs
mapped_all$lfc <- significant_data$lfc[match(mapped_all$name, significant_data$name)]

# Manually rescale lfc to [0,1]
lfc_vals <- mapped_all$lfc
lfc_min <- min(lfc_vals, na.rm = TRUE)
lfc_max <- max(lfc_vals, na.rm = TRUE)

lfc_scaled <- if (lfc_max == lfc_min) {
  rep(0.5, length(lfc_vals))
} else {
  (lfc_vals - lfc_min) / (lfc_max - lfc_min)
}

# Create color palette and assign
color_fun <- colorRampPalette(c("blue", "white", "firebrick"))
deg_colors <- color_fun(100)[as.numeric(cut(lfc_scaled, breaks = 100))]
mapped_all$color <- ifelse(mapped_all$type == "variant", "moccasin", deg_colors)

# Build graph from all mapped STRING IDs
full_graph <- string_db$get_graph()
graph_all <- induced_subgraph(full_graph, vids = mapped_all$STRING_id)
graph_all <- simplify(graph_all, remove.loops = TRUE, remove.multiple = TRUE)

# Keep all DEGs
deg_ids <- mapped_all$STRING_id[mapped_all$type == "DEG"]

# From variant-only genes, keep top 20 by degree
variant_ids <- mapped_all$STRING_id[mapped_all$type == "variant"]
variant_ids_in_graph <- intersect(variant_ids, V(graph_all)$name)
variant_degrees <- degree(graph_all, v = variant_ids_in_graph)
top_variant_ids <- names(sort(variant_degrees, decreasing = TRUE))[1:10]

# Final node set = all DEGs + top variant genes
final_ids <- unique(c(deg_ids, top_variant_ids))
graph <- induced_subgraph(graph_all, vids = final_ids)

# Reapply aesthetics
label_map <- setNames(mapped_all$name, mapped_all$STRING_id)
color_map <- setNames(mapped_all$color, mapped_all$STRING_id)

V(graph)$label <- label_map[V(graph)$name]
V(graph)$color <- color_map[V(graph)$name]
V(graph)$frame.color <- "white"
V(graph)$label.color <- "black"
V(graph)$size <- 8

# Layout
layout <- layout_with_fr(graph, niter = 2000, area = vcount(graph)^3)

# Save plot
png("output/publication-analysis/mecfs_deg_variant_network.png", width = 1600, height = 1000, res = 300)
plot(graph,
     vertex.label.cex = 0.75,
     edge.color = "black",
     edge.width = 1,
     layout = layout)
dev.off()
```

#### Genes of Interest Plot Counts

```{r, generate-plot-counts-genes-interest-subsetted}
# List of gene names to remove or keep
spta1_genes <- c(
  "AHSP", "HEMGN", "SLC4A1", "KEL", "SPTA1", "RHAG",
  "GYPE", "GYPA", "GYPB", "EPB42", "SPTB", "SPTBN5"
)

# Define paths
output_path <- "output/publication-analysis/batch-correction-limma/plot-counts/genes-of-interest"

filename <- file.path(output_path, "genes-of-interest-heatmap.png")

# Filter genes
filtered_without_spta1_genes <- filter_genes(filtered_by_interest, spta1_genes, include = FALSE)

spta1_genes_only <- filter_genes(filtered_by_interest, filtered_without_spta1_genes, include = FALSE)

# Generate plots and results using the modularized functions
results <- process_genes_of_interest(
  filtered_data = filtered_by_interest,
  dds = dds,
  vsd = vsd_limma,
  genes_to_filter = spta1_genes,
  output_path = output_path
)

# Extract the faceted plot and gene results
faceted_plot <- results$faceted_plot
gene_results_df <- results$gene_results_df

# Save the gene results to a CSV
file_name <- file.path(output_path, "genes_of_interest_plot_counts_signals.csv")
write.csv(gene_results_df, file_name, row.names = FALSE)

# Prepare the heatmap data
mat3 <- assay(vsd_limma)[filtered_without_spta1_genes$Ensembl_ID, ]
rownames(mat3) <- gene_info$gene_name[match(filtered_without_spta1_genes$Ensembl_ID, gene_info$Ensembl_ID)]
df_sub <- as.data.frame(colData(vsd_limma)[, c("Affected", "Category")])

# Create the heatmap
create_heatmap(
  mat = mat3,
  gene_info = gene_info,
  vsd_coldata = colData(vsd_limma),
  output_path = filename,
  ann_colors = ann_colors
)
```


### SPTA1 Genes of Interest

```{r, generate-plot-counts-genes-interest-spta1}
# Define the output path
output_path <- "output/publication-analysis/batch-correction-limma/plot-counts/spta1-genes-of-interest"

# Generate plots and results using the modularized function
results <- process_genes_of_interest(
  filtered_data = filtered_by_interest,
  dds = dds,
  vsd = vsd_limma,
  genes_to_filter = filtered_without_spta1_genes$gene_name,
  output_path = output_path
)

# Extract the faceted plot and gene results
faceted_plot <- results$faceted_plot
gene_results_df <- results$gene_results_df

# Save the gene results to a CSV
file_name <- file.path(output_path, "genes_of_interest_plot_counts_signals.csv")
write.csv(gene_results_df, file_name, row.names = FALSE)

# Prepare data for the heatmap
mat_spta1 <- assay(vsd_limma)[spta1_genes_only$Ensembl_ID, ]
rownames(mat_spta1) <- gene_info$gene_name[match(spta1_genes_only$Ensembl_ID, gene_info$Ensembl_ID)]
annotation_data <- as.data.frame(colData(vsd_limma)[, c("Affected", "Category")])

# Generate a heatmap for SPTA1 genes
create_heatmap(
  mat = mat_spta1,
  gene_info = gene_info,
  vsd_coldata = colData(vsd_limma),
  output_path = file.path(output_path, "spta1_genes_of_interest_heatmap.png"),
  ann_colors = ann_colors
)
```


### Significant Genes Plot Counts

```{r, generate-plot-counts-genes-significant}
# Define the output path
output_path <- "output/publication-analysis/batch-correction-limma/plot-counts/padj-05"

# Generate plots and results using the modularized function
results <- process_genes_of_interest(
  dds = dds,
  vsd = vsd_limma,
  output_path = output_path,
  preprocessed_data = res_aff_vs_unaff_df_genename_padj05_lfc1
)

# Extract the faceted plot and gene results
faceted_plot <- results$faceted_plot
gene_results_df <- results$gene_results_df

# Save the gene results to a CSV
file_name <- file.path(output_path, "significant_genes_plot_counts_signals.csv")
write.csv(gene_results_df, file_name, row.names = FALSE)

# Prepare data for the heatmap
mat_significant <- assay(vsd_limma)[res_aff_vs_unaff_df_genename_padj05_lfc1$Ensembl_ID, ]
rownames(mat_significant) <- res_aff_vs_unaff_df_genename_padj05_lfc1$gene_name[match(
  res_aff_vs_unaff_df_genename_padj05_lfc1$Ensembl_ID,
  res_aff_vs_unaff_df_genename_padj05_lfc1$Ensembl_ID
)]
annotation_data <- as.data.frame(colData(vsd_limma)[, c("Affected", "Category")])

# Generate a heatmap for significant genes
create_heatmap(
  mat = mat_significant,
  gene_info = gene_info,
  vsd_coldata = colData(vsd_limma),
  output_path = file.path(output_path, "significant_genes_heatmap.png"),
  ann_colors = ann_colors
)
```

## Save data

```{r, save-data}
save.image(file = "output/publication-analysis/publication-analysis.RData")
```
