---
title: "All Sample Differential Gene Expression (DGE) Analysis"
output:
  workflowr::wflow_html:
    toc: true
    toc_depth: 3
    toc_float: true
    code_folding: hide
editor_options:
  chunk_output_type: console
---

```{r, setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# DGE Analysis Setup

Ensure you have all necessary libraries installed and load the helper code.

At a later date, `renv` will be integrated to ensure reproducibility of this analysis.

Use the below code to install these packages:

```
# Install packages from CRAN
install.packages(c("tidyverse", "RColorBrewer", "pheatmap", "gprofiler2", "plotly", "ggupset", 
                   "data.table", "lubridate", "reshape2", "viridis", "scales", "cowplot", 
                   "patchwork", "ggrepel", "ggpubr", "forcats", "readxl", "openxlsx", 
                   "rmarkdown"))

# Install packages from Bioconductor
install.packages("BiocManager")
BiocManager::install(c("DESeq2", "genefilter", "limma", "biomaRt", "mygene", 
                       "edgeR", "ComplexHeatmap", "clusterProfiler", "AnnotationDbi", 
                       "pathview", "org.Hs.eg.db", "ReactomePA", "DOSE", "enrichR", 
                       "STRINGdb"))
```

```{r, load libraries, warning = FALSE, message = FALSE}
library(tidyverse) # Available via CRAN
library(DESeq2) # Available via Bioconductor
library(RColorBrewer) # Available via CRAN
library(pheatmap) # Available via CRAN
library(genefilter) # Available via Bioconductor
library(limma) # Available via Bioconductor
library(gprofiler2) # Available via CRAN
library(biomaRt) # Available via Bioconductor
library(plotly) # Available via CRAN
library(ggpubr) # Available via CRAN
library(rmarkdown) # Available via CRAN
library(clusterProfiler) # Available via Bioconductor
library(org.Hs.eg.db) # Available via Bioconductor
library(ggrepel) # Available via CRAN
library(ReactomePA) # Available via Bioconductor
library(mygene) # Available via Bioconductor
library(DOSE) # Available via Bioconductor
library(enrichR) # Available via Bioconductor
library(STRINGdb) # Available via Bioconductor
library(EnhancedVolcano)
library(ComplexHeatmap)
```

```{r, include=FALSE}
source("code/helpers.R", local = knitr::knit_global())
# or sys.source("your-script.R", envir = knitr::knit_global())
```

## Data Import

We will be importing counts data from the star-salmon pipeline and our metadata 
for the project which is hosted on Box. This also ensures data is properly ordered by sample id.

```{r, import data}
# Import counts and metadata
sample_metadata <- read_csv("data/Metadata_2024_11_20.csv")
row.names(sample_metadata) <- sample_metadata$ID
counts <- read_tsv("data/star-salmon/salmon_merged_gene_counts_length_scaled.tsv")

# Import variants of interest
genes_of_interest <- read_csv("data/Prioritized_Genes_From_WGS_2024_11_19.csv")
genes_of_interest <- unique(genes_of_interest$Genes)
genes_of_interest <- genes_of_interest[!is.na(genes_of_interest)]

# Use first column (gene_id) for row names
counts <- data.frame(counts, row.names = 1, check.names = FALSE)
counts$Ensembl_ID <- row.names(counts)
drop <- c("Ensembl_ID", "gene_name")
gene_info <- counts[, drop]
counts <- counts[, !(names(counts) %in% drop)] # remove both columns

# Check that data is ordered properly
sample_metadata <- check_order(sample_metadata = sample_metadata, counts = counts)

genes_biomart <- retrieve_gene_info(values = gene_info$Ensembl_ID, filters = "ensembl_gene_id_version")
```

## DESeq2 Analysis

```{r, start analysis}
sample_metadata$Family <- factor(sample_metadata$Family)
sample_metadata$Affected <- factor(sample_metadata$Affected)
sample_metadata$Batch <- factor(sample_metadata$Batch)
sample_metadata$Sex <- factor(sample_metadata$Sex)
sample_metadata$Ancestry <- factor(sample_metadata$Ancestry)
sample_metadata$SubCategory <- factor(sample_metadata$SubCategory)
sample_metadata$Category <- factor(sample_metadata$Category)
sample_metadata$OverallCategory <- factor(sample_metadata$`Overall category assigned`)

# Account for Family later but batch is accounted for
# Accounting for another factor seems to be an issue.
dds <- DESeqDataSetFromMatrix(
  countData = round(counts), colData = sample_metadata,
  design = ~ Batch + Affected
)

# Pre-filtering: Keep only rows that have at least 10 reads total
keep <- rowSums(counts(dds)) >= 50
dds <- dds[keep, ]

# Run DESeq function
dds <- DESeq(dds)

# Normalize gene counts for differences in seq. depth/global differences
counts_norm <- counts(dds, normalized = TRUE)
```

### Data transformation and visualization

Perform count data transformation by variance stabilizing transformation (vst) on normalized counts.

```{r, vsd}
vsd <- vst(dds, blind = FALSE)
```

### Batch correction with limma

```{r, limma}
counts_vst <- assay(vsd)
write.csv(counts_vst, file = "output/all-samples-analysis/counts_vst.csv")
mm <- model.matrix(~ Batch + Affected, colData(vsd))

counts_vst_limma <- limma::removeBatchEffect(counts_vst,
  batch = vsd$Batch,
  design = mm
)

write.csv(counts_vst_limma, file = "output/all-samples-analysis/counts_vst_limma.csv")

vsd_limma <- vsd
assay(vsd_limma) <- counts_vst_limma
```

### Sample distances heatmap

```{r, sample-dist-heatmap}
sample_dists_all <- dist(t(assay(vsd_limma)))
sample_dist_matrix_all <- as.matrix(sample_dists_all)
rownames(sample_dist_matrix_all) <- paste(vsd_limma$Batch, vsd_limma$Affected,
  sep = " | "
)
colnames(sample_dist_matrix_all) <- paste(vsd_limma$ID, vsd_limma$Affected,
  sep = " | "
)
colors <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)

pheatmap(sample_dist_matrix_all,
  clustering_distance_rows = sample_dists_all,
  clustering_distance_cols = sample_dists_all, col = colors
)
```

### Principal Components Analysis

Our below PCA shows that there does not seem to be a batch-related effect 
occurring after using limma. However, we can see that our 3 male samples are 
grouping. Given this knowledge, removing them from downstream analyses is the best option.

```{r, principal-components-analysis-all}
pca_data_all <- plotPCA(vsd_limma,
  intgroup = c("Batch", "Affected", "Sex"),
  returnData = TRUE
)
percent_var_all <- round(100 * attr(pca_data_all, "percentVar"))

ggplot(pca_data_all, aes(PC1, PC2)) +
  geom_point(aes(colour = Affected, fill = Sex, shape = Batch), size = 4) +
  scale_shape_manual(values = c(21, 22, 23)) +
  scale_fill_manual(values = c("white", "gray")) +
  scale_color_manual(values = c("blue", "red")) +
  geom_text(aes(label = name),
    data = subset(pca_data_all, PC2 < -18 | PC1 < -30),
    vjust = -1, hjust = 0.5, size = 2.5
  ) +
  xlab(paste0("PC1: ", percent_var_all[1], "% variance")) +
  ylab(paste0("PC2: ", percent_var_all[2], "% variance")) +
  coord_fixed()
```

```{r, principal-components-analysis-combocategory-all}
pca_data_all <- plotPCA(vsd_limma,
  intgroup = c(
    "Affected", "Sex",
    "OverallCategory"
  ),
  returnData = TRUE
)
percent_var_all <- round(100 * attr(pca_data_all, "percentVar"))

ggplot(pca_data_all, aes(PC1, PC2)) +
  geom_point(aes(colour = OverallCategory, fill = Sex, shape = Affected), size = 4) +
  scale_shape_manual(values = c(21, 22, 23)) +
  scale_fill_manual(values = c("white", "gray")) +
  geom_text(aes(label = name), vjust = -1, hjust = 0.65, size = 5) +
  # geom_text_repel(aes(label = name), size = 5, vjust = -1, hjust = -0.65) +
  xlab(paste0("PC1: ", percent_var_all[1], "% variance")) +
  ylab(paste0("PC2: ", percent_var_all[2], "% variance")) +
  coord_fixed()
```

### Heatmap of all genes, top 50  & top 100 genes

```{r, heatmap-colors, out.height="570px", out.width ="800px"}
# Specify annotation colors by columns
# Use RColorBrewer::brewer.pal(n=10, name="Set1")
category_colors <- c(
  "Autoimmune disorder" = "#B3DE69",
  "Immunodeficiency" = "#FFFFB3",
  "Channelopathy" = "#BEBADA",
  "Inflammatory disorder" = "#FB8072",
  "Metabolic disorder" = "#80B1D3",
  "Mitochondrial disorder" = "#FCCDE5",
  "Neurologic disorder" = "#D9D9D9",
  "Myasthenic disorder" = "#FDB462",
  "Neuropathy" = "#8DD3C7",
  "Unaffected" = "darkgrey"
)

combined_category_colors <- c(
  "E" = "#E41A1C", # Dark green
  "C-I" = "#377EB8", # Dark orange
  "E-I" = "#4DAF4A", # Light purple
  "C" = "#984EA3", # Magenta
  "I" = "#FF7F00", # Light green
  "C-E" = "#FFFF33", # Mustard yellow
  "S" = "#F781BF", # Brown
  "Unaffected" = "darkgray" # Dark grey
)

overall_category_colors <- c(
  "ENE" = "#BFDFBF", # Magenta
  "IMM" = "#EEBFEE", # Light green
  "SOL" = "#FFFF33", # Mustard yellow
  "STR" = "#BFBFFF", # Brown
  "N/A" = "darkgray" # Dark grey
)

# Specify colors
ann_colors <- list(
  Batch = c(B1 = "purple", B2 = "firebrick", B3 = "yellow"),
  Affected = c(Affected = "green", Unaffected = "navy"),
  SubCategory = category_colors,
  Category = combined_category_colors,
  OverallCategory = overall_category_colors
)

ann_colors2 <- list(
  Batch = c(B1 = "purple", B2 = "firebrick", B3 = "yellow"),
  Affected = c(Affected = "green", Unaffected = "navy"),
  SubCategory = category_colors,
  Category = combined_category_colors
)

ann_colors3 <- list(
  Batch = c(B1 = "purple", B2 = "firebrick", B3 = "yellow"),
  Affected = c(Affected = "green", Unaffected = "navy"),
  SubCategory = category_colors,
  Category = combined_category_colors,
  OverallCategory = overall_category_colors
)
```

This is a heatmap of the top 50 genes with the highest variance across samples

```{r, top50-heatmap-batch-combined, out.height="570px", out.width ="800px"}
top_var_genes <- head(order(-rowVars(assay(vsd_limma))), 50)
mat <- assay(vsd_limma)[top_var_genes, ]
mat <- mat - rowMeans(mat)
df <- as.data.frame(colData(vsd_limma)[, c("Batch", "Affected", "OverallCategory")])

ensembl_to_gene <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)

# Get the current row names of the matrix 'mat'
current_ensembl_ids <- rownames(mat)

# Find the corresponding gene names for the Ensembl IDs
new_row_names <- ensembl_to_gene[current_ensembl_ids]

# Set the new row names for the matrix 'mat'
rownames(mat) <- new_row_names

ComplexHeatmap::pheatmap(mat,
  annotation_col = df, annotation_colors = ann_colors3,
  fontsize = 5, angle_col = c("0")
)
```


### Comparison/Contrast of Affected_Affected_vs_Unaffected 

```{r}
res_aff_vs_unaff <- results(dds, contrast = c("Affected", "Affected", "Unaffected"))
res_aff_vs_unaff_df <- process_and_save_results(
  res_aff_vs_unaff,
  "output/all-samples-analysis/res_aff_vs_unaff.csv"
)
res_aff_vs_unaff_df <- arrange(res_aff_vs_unaff_df, padj)
res_aff_vs_unaff_df_05 <- subset(res_aff_vs_unaff_df, padj < 0.05)
res_aff_vs_unaff_df_1 <- subset(res_aff_vs_unaff_df, padj < 0.1)

res_aff_vs_unaff_df_padj05_lfc1 <- subset(res_aff_vs_unaff_df_05, log2FoldChange >= 1 | log2FoldChange <= -1)

summary(res_aff_vs_unaff)
```

```{r, compare-7-and-8}
# topgenes_byensemblid <- head(rownames(res_aff_vs_unaff_df), 1000)
# topgenes_aff_vs_unaff_1000 <- assay(vsd_limma)[topgenes_byensemblid, ]
# topgenes_aff_vs_unaff_1000 <- topgenes_aff_vs_unaff_1000 - rowMeans(topgenes_aff_vs_unaff_1000)
#
# samples_to_compare <- c("7", "8")  # Replace with actual sample names or column indices
# sample_expression <- topgenes_aff_vs_unaff_1000[, samples_to_compare]
#
# ensembl_to_gene <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)
#
# # Get the current row names of the matrix 'mat'
# current_ensembl_ids <- rownames(sample_expression)
#
# # Find the corresponding gene names for the Ensembl IDs
# new_row_names <- ensembl_to_gene[current_ensembl_ids]
#
# # Set the new row names for the matrix 'mat'
# rownames(sample_expression) <- new_row_names
#
# sample_expression<- sample_expression[order(row.names(sample_expression)), ]
#
# df <- as.data.frame(colData(vsd_limma)[samples_to_compare, c("Affected", "OverallCategory")])
# pheatmap(sample_expression, annotation_col = df, annotation_colors = ann_colors3, fontsize = 5, angle_col = c("0"))
#
# expression_difference <- sample_expression[, "7"] - sample_expression[, "8"]
# diff_df <- data.frame(Gene = rownames(sample_expression),
#                       Diff = expression_difference)
# head(diff_df[order(abs(diff_df$Diff), decreasing=TRUE), ], 20)  # Top 20 largest differences
#
# top_diff_genes <- head(diff_df[order(abs(diff_df$Diff), decreasing=TRUE), ], 20)
# barplot(top_diff_genes$Diff, names.arg=top_diff_genes$Gene,
#         las=2, col="steelblue",
#         main="Top Differential Genes Between Sample 7 and Sample 8",
#         ylab="Expression Difference")
```


## Heatmap of Significant Genes


```{r, significant-genes-deseq-lfc1, out.height="800px", out.width ="1200px"}
# Assuming 'res_aff_vs_unaff_df' has a column 'padj' for adjusted p-values or 'pvalue' for p-values
# Ensure the row names of 'res_aff_vs_unaff_df' are Ensembl IDs
res_aff_vs_unaff_df_padj05_lfc1 <- res_aff_vs_unaff_df[order(res_aff_vs_unaff_df_padj05_lfc1$padj), ]

# Get the most significant genes based on adjusted p-values and log2foldchange of 1
topgenes_byensemblid <- rownames(res_aff_vs_unaff_df_padj05_lfc1)


# Extract the corresponding subset of the data matrix
topgenes_aff_vs_unaff_05 <- assay(vsd_limma)[topgenes_byensemblid, ]

# Normalize by subtracting the row means
topgenes_aff_vs_unaff_05 <- topgenes_aff_vs_unaff_05 - rowMeans(topgenes_aff_vs_unaff_05)

# Map Ensembl IDs to gene names
ensembl_to_gene <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)
current_ensembl_ids <- rownames(topgenes_aff_vs_unaff_05)
new_row_names <- ensembl_to_gene[current_ensembl_ids]
rownames(topgenes_aff_vs_unaff_05) <- new_row_names

# Order the matrix based on significance (most significant to least significant)
topgenes_aff_vs_unaff_05 <- topgenes_aff_vs_unaff_05[order(res_aff_vs_unaff_df$padj[topgenes_byensemblid]), ]

df <- df <- colData(vsd_limma) %>%
  as.data.frame() %>%
  dplyr::select(OverallCategory)

ComplexHeatmap::pheatmap(topgenes_aff_vs_unaff_05, color = colorRampPalette(rev(brewer.pal(
  n = 9, name =
    "RdYlBu"
)))(50), annotation_col = df, annotation_colors = ann_colors3, fontsize = 7, angle_col = c("0"), cellheight = 10, cellwidth = 24, border_color = "black", heatmap_legend_param = list(
  title = ""
))
```


```{r, all-genes-list}
gb_df <- genes_biomart[, c(1, ncol(genes_biomart))]
res_aff_vs_unaff_df_genename <- res_aff_vs_unaff_df
res_aff_vs_unaff_df_genename$Ensembl_ID <- row.names(res_aff_vs_unaff_df)
res_aff_vs_unaff_df_genename <- merge(x = res_aff_vs_unaff_df_genename, y = gene_info, by.x = "Ensembl_ID", by.y = "Ensembl_ID", all.x = TRUE)
res_aff_vs_unaff_df_genename <- res_aff_vs_unaff_df_genename[, c(dim(res_aff_vs_unaff_df_genename)[2], 1:dim(res_aff_vs_unaff_df_genename)[2] - 1)]
res_aff_vs_unaff_df_genename <- res_aff_vs_unaff_df_genename[order(res_aff_vs_unaff_df_genename[, "padj"]), ]
write.csv(res_aff_vs_unaff_df_genename, file = "output/all-samples-analysis/res_aff_vs_unaff_df_genename.csv")
```

## Volcano Plot
```{r, volcano-plot, out.height="1000px", out.width ="1600px"}
ev <- EnhancedVolcano(res_aff_vs_unaff_df_genename,
  lab = res_aff_vs_unaff_df_genename$gene_name,
  x = "log2FoldChange",
  y = "padj",
  selectLab = c(
    "SLC4A10", "SNTG2", "KCNQ5", "DEFA1",
    "CD248", "POLR3G", "ZNF683"
  ),
  xlab = bquote(~ Log[2] ~ "fold change"),
  ylab = bquote(~ Log[10] ~ "padj"),
  pCutoff = .05,
  FCcutoff = 1.0,
  pointSize = 2.0,
  labSize = 4.0,
  labCol = "black",
  labFace = "bold",
  boxedLabels = TRUE,
  colAlpha = 4 / 5,
  legendPosition = "bottom",
  legendLabSize = 14,
  legendIconSize = 4.0,
  drawConnectors = TRUE,
  widthConnectors = 1.0,
  colConnectors = "black",
  legendLabels = c(
    " NS", bquote(~ Log[2] ~ "fold change"), " padj",
    bquote(~ Log[2] ~ "fold change and padj")
  ),
  title = "Affected versus Unaffected",
  subtitle = "Differential Gene Expression Analysis in ME/CFS Patients"
)

ev <- ev + ggplot2::coord_cartesian(xlim = c(-25, 25)) +
  ggplot2::scale_x_continuous(breaks = seq(-25, 25, 5)) +
  ggplot2::scale_y_continuous(breaks = seq(0, 7, 1))
ggsave(plot = ev, filename = "output/all-samples-analysis/analysis-volcano-plot.png", device = "png", width = 14, dpi = 1200, units = "in", create.dir = TRUE)
```


```{r, significant-with-genename-padj-lfc}
res_aff_vs_unaff_df_genename_05 <- subset(res_aff_vs_unaff_df_genename, padj < 0.05)
res_aff_vs_unaff_df_genename_05 <- res_aff_vs_unaff_df_genename_05[order(res_aff_vs_unaff_df_genename_05$padj), ]
write.csv(res_aff_vs_unaff_df_genename_05, file = "output/all-samples-analysis/res_spta1_vs_unaff_df_genename_05.csv")

res_aff_vs_unaff_df_genename_padj05_lfc1 <- subset(res_aff_vs_unaff_df_genename_05, log2FoldChange >= 1 | log2FoldChange <= -1)
res_aff_vs_unaff_df_genename_padj05_lfc1 <- res_aff_vs_unaff_df_genename_padj05_lfc1[order(res_aff_vs_unaff_df_genename_padj05_lfc1$padj), ]
write.csv(res_aff_vs_unaff_df_genename_padj05_lfc1, file = "output/all-samples-analysis/res_spta1_vs_unaff_df_genename_padj05_lfc1.csv")


res_aff_vs_unaff_df_genename_1 <- subset(res_aff_vs_unaff_df_genename, padj < 0.1)
res_aff_vs_unaff_df_genename_1 <- res_aff_vs_unaff_df_genename_1[order(res_aff_vs_unaff_df_genename_1$padj), ]
write.csv(res_aff_vs_unaff_df_genename_1, file = "output/all-samples-analysis/res_spta1_vs_unaff_df_genename_padj1.csv")

res_aff_vs_unaff_df_genename_padj1_lfc1 <- subset(res_aff_vs_unaff_df_genename_1, log2FoldChange >= 1 | log2FoldChange <= -1)
res_aff_vs_unaff_df_genename_padj1_lfc1 <- res_aff_vs_unaff_df_genename_padj1_lfc1[order(res_aff_vs_unaff_df_genename_padj1_lfc1$padj), ]
write.csv(res_aff_vs_unaff_df_genename_padj1_lfc1, file = "output/all-samples-analysis/res_spta1_vs_unaff_df_genename_padj1_lfc1.csv")
```

Below is a table of information about the top genes.

```{r, padj-gene-info}
genes <- res_aff_vs_unaff_df_genename_05$gene_name
my_gene_data <- queryMany(genes, scopes = "symbol", fields = c("symbol", "name", "summary", species = "human"))
my_gene_data_unique <- as.data.frame(my_gene_data) %>% dplyr::distinct(query, .keep_all = TRUE)
# paged_table(my_gene_data, options = list(rows.print = 15))
```

```{r, maplot-samples}
filtered_gene_names <- res_aff_vs_unaff_df_genename$gene_name[!grepl("^ENS", res_aff_vs_unaff_df_genename$gene_name)]
# Select specific genes to show
# set top = 0, then specify genes using label.select argument
maplot <- ggmaplot(res_aff_vs_unaff_df,
  main = "Affected vs Unaffected MA Plot",
  fdr = .1, fc = 1, size = 0.4, # Same used for others.
  genenames = as.vector(res_aff_vs_unaff_df_genename$gene_name),
  ggtheme = ggplot2::theme_minimal(),
  legend = "top", top = 30,
  label.select = c("KCNQ5"),
  font.label = c("bold", 6), label.rectangle = TRUE,
  font.legend = "bold", font.main = "bold"
)

maplot

significant_data <- maplot$data %>%
  filter(grepl("Up|Down", sig)) %>%
  mutate(direction = ifelse(grepl("Up", sig), "Up", "Down")) %>%
  dplyr::select(-sig) # This removes the 'sig' column

# Combine DataFrames based on matching 'query' in my_gene_data_unique to 'gene' in significant_data
combined_data <- inner_join(my_gene_data_unique, significant_data, by = c("query" = "name"))

combined_data <- combined_data %>%
  dplyr::select(-notfound, -X_id, -X_score) %>%
  rename(gene = query)

paged_table(as.data.frame(significant_data), options = list(rows.print = 30))
# Save significant genes
write.csv(significant_data, file = "output/all-samples-analysis/res_aff_vs_unaff_significant_samples.csv", row.names = FALSE)

# Save significant genes
write.csv(combined_data, file = "output/all-samples-analysis/res_aff_vs_unaff_significant_mygene.csv", row.names = FALSE)
```

## Expression of Candidate Genes

Below is a table of expression of the genes identified during our WGS analysis.

```{r, genes-of-interest-table}
# Subset gene_info using genes of interest
subset_gene_info <- gene_info[gene_info$gene_name %in% genes_of_interest, ]

filtered_by_interest <- filter(res_aff_vs_unaff_df_genename, Ensembl_ID %in% subset_gene_info$Ensembl_ID)

# Filtering the dataframe by row names
filtered_counts <- counts[row.names(counts) %in% subset_gene_info$Ensembl_ID, ]

# Match and update row names
matching_indices <- match(rownames(filtered_counts), subset_gene_info$Ensembl_ID)

# Update row names based on matching_column values from metadata
rownames(filtered_counts) <- subset_gene_info$gene_name[matching_indices]

missing_genes <- setdiff(subset_gene_info$Ensembl_ID, filtered_by_interest$Ensembl_ID)

corresponding_gene_names <- subset_gene_info$gene_name[subset_gene_info$Ensembl_ID %in% missing_genes]

missing_gene_counts <- counts[row.names(counts) %in% missing_genes, ]

paged_table(filtered_by_interest, options = list(rows.print = 15))

paged_table(filtered_counts, options = list(rows.print = 15))
```


```{r, stringdb-network-combined}
string_db <- STRINGdb$new(version = "11.5", species = 9606, score_threshold = 200, network_type = "full", input_directory = "")

significant_data_copy <- significant_data %>%
  rename(gene_name = name, log2FoldChange = lfc, baseMean = mean)

# Ensure both dataframes have the same columns (optional step to demonstrate alignment)
# This step is not necessary if you are sure both dataframes are already aligned
significant_data_copy <- significant_data_copy[c("gene_name", "baseMean", "log2FoldChange")]
filtered_by_interest2 <- filtered_by_interest[c("gene_name", "baseMean", "log2FoldChange")]

combined_df <- dplyr::bind_rows(significant_data_copy, filtered_by_interest2)

combined_df_mapped <- string_db$map(combined_df, "gene_name", removeUnmappedRows = TRUE)

combined_hits <- combined_df_mapped$STRING_id

string_db$plot_network(combined_hits)
combined_enrichment <- string_db$get_enrichment(combined_hits)

enrich_file_name <- "output/all-samples-analysis/stringdb_combined_enrichment.csv"
write.csv(combined_enrichment, enrich_file_name, row.names = FALSE)
```


## Genes of Interest Plot Counts

```{r, generate-plot-counts-genes-interest}
# Create an empty list to store the results for each gene
gene_results_list <- list()

# Create an empty dataframe to store all counts data for plotting
gi_all_counts <- data.frame()

# List of gene names to remove or keep
blood_genes <- c(
  "AHSP", "HEMGN", "SLC4A1", "KEL", "SPTA1", "RHAG",
  "GYPE", "GYPA", "GYPB", "EPB42", "SPTB", "SPTBN5"
)

madd_genes <- c(
  "ADM2", "TSHB", "PTH2", "ADORA2B", "GIP", "CGA", "CALCB", "IGHV3-16",
  "ADORA2A", "SYT6", "CYTH2", "VIPR2", "HTR6", "LHCGR", "GIPR", "CGB8",
  "DENND1A", "MADD", "DMXL2", "SMCR8", "TP53TG5", "IGHV3OR16-9"
)

mito_genes <- c(
  "ETFB", "PGM1", "PCK2", "GLYCTK", "ACACB", "MLYCD", "MCCC1",
  "CPT1A", "ELOVL4", "G6PD", "ACADVL", "ACADM", "HADHA", "MCCC2",
  "CPT1C", "CPT1B", "ENO3", "SURF1", "CUBN", "MMACHC", "LMBRD1",
  "MINPP1", "MMAA", "TACO1"
)


combined_genes <- c(blood_genes, madd_genes, mito_genes)

# Remove specific genes
filtered_without_genes <- filtered_by_interest %>%
  filter(!gene_name %in% combined_genes)

# Keep only specific genes
filtered_with_only_genes <- filtered_by_interest %>%
  filter(gene_name %in% blood_genes)

# Keep only specific genes
filtered_with_only_madd_genes <- filtered_by_interest %>%
  filter(gene_name %in% madd_genes)

# Keep only specific genes
filtered_with_only_mito_genes <- filtered_by_interest %>%
  filter(gene_name %in% mito_genes)

# Save the data frames as CSV files

# Filtered data without specific genes
write.csv(filtered_without_genes, "output/all-samples-analysis/other_genes_of_interest.csv", row.names = FALSE)

# Filtered data with only specific genes (genes_to_filter)
write.csv(filtered_with_only_genes, "output/all-samples-analysis/slc4a1_genes_of_interest.csv", row.names = FALSE)

# Filtered data with only specific MADD genes
write.csv(filtered_with_only_madd_genes, "output/all-samples-analysis/madd_genes_of_interest.csv", row.names = FALSE)

# Filtered data with only specific MADD genes
write.csv(filtered_with_only_mito_genes, "output/all-samples-analysis/mito_genes_of_interest.csv", row.names = FALSE)


# Loop through each gene to calculate and plot counts
for (ensembl_id in filtered_without_genes$Ensembl_ID) {
  d <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  dp <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  gene_name <- filtered_without_genes$gene_name[filtered_without_genes$Ensembl_ID == ensembl_id]

  # Calculate the mean and standard deviation of counts within each condition
  d_stats <- d %>%
    group_by(Affected) %>%
    summarise(
      mean_count = mean(count),
      sd_count = sd(count)
    )

  # Merge statistics back with the data
  d <- merge(d, d_stats, by = "Affected")

  # Create a temporary dataframe to store results for this gene
  temp_gene_df <- data.frame(
    Patient = rownames(d),
    stringsAsFactors = FALSE
  )

  # Calculate Z-scores and determine regulation status
  regulation_status <- sapply(1:nrow(d), function(i) {
    z_score <- (d$count[i] - d$mean_count[i]) / d$sd_count[i]

    # Determine regulation status based on Z-score
    if (z_score > 1) {
      return("Upregulated")
    } else if (z_score < -1) {
      return("Downregulated")
    } else {
      return("Neutral")
    }
  })

  # Add the regulation status to the temporary dataframe
  temp_gene_df[[gene_name]] <- regulation_status

  # Merge the temporary dataframe with the results list
  if (length(gene_results_list) == 0) {
    gene_results_list[[1]] <- temp_gene_df
  } else {
    gene_results_list[[1]] <- merge(gene_results_list[[1]], temp_gene_df, by = "Patient", all = TRUE)
  }

  # Add the gene name to the dp dataframe
  dp$Gene <- gene_name
  dp$Ensembl_ID <- ensembl_id
  dp$SampleID <- rownames(dp)

  # Combine dp with all_counts dataframe
  gi_all_counts <- rbind(gi_all_counts, dp)

  # Generate the boxplot
  gene_plot <- ggboxplot(dp,
    x = "Affected", y = "count", add = "jitter",
    color = "Affected", palette = c("red", "navy"),
    title = gene_name
  ) +
    geom_text_repel(aes(label = rownames(dp))) +
    scale_color_manual(
      name = "Affected Status",
      labels = c("Affected", "Unaffected"),
      values = c("red", "navy")
    )
  print(gene_plot) # Ensure each plot is printed during the loop
  ggsave(
    filename = paste0(gene_name, "-plot-counts.png"),
    path = "output/all-samples-analysis/batch-correction-limma/plot-counts/genes-of-interest",
    plot = gene_plot, dpi = 450, create.dir = TRUE
  )
}

# Create the faceted plot
faceted_plot <- ggplot(gi_all_counts, aes(x = Affected, y = count, color = Affected)) +
  geom_boxplot(alpha = 0.35) +
  geom_jitter(width = 0.2, size = .45) + # Adjust size of the dots
  geom_text_repel(aes(label = SampleID),
    size = 2,
    max.overlaps = Inf, force = 10, color = "black",
    segment.color = "gray",
    min.segment.length = 0,
    point.padding = 0.1
  ) + # Add labels to the dots
  facet_wrap(~Gene, scales = "free_y") +
  theme_bw() +
  labs(title = "Gene Expression Counts by Affected Status", x = "Affected Status", y = "Count") +
  scale_color_manual(values = c("red", "navy")) +
  theme(
    legend.position = "bottom",
    plot.margin = margin(10, 10, 10, 10),
    strip.text = element_text(size = 4), # Adjust facet label text size
    plot.title = element_text(size = 10),
    axis.title = element_text(size = 10),
    axis.text = element_text(size = 4),
    panel.spacing = unit(.35, "lines") # Add space between facets
  ) +
  coord_cartesian(clip = "off") # Ensure labels are not clipped


faceted_plot

# Save the faceted plot
ggsave(
  filename = "faceted_genes_of_interest_plot_counts.png",
  path = "output/all-samples-analysis/batch-correction-limma/plot-counts/genes-of-interest",
  plot = faceted_plot, dpi = 2200, create.dir = TRUE
)

# Convert the list to a dataframe
gene_results_df <- gene_results_list[[1]]

file_name <- "output/all-samples-analysis/genes_of_interest_plot_counts_signals.csv"
write.csv(gene_results_df, file_name, row.names = FALSE)
```



Below is a heatmap highlighting the expression of our genes of interest across batch, disease group, and affected status.

```{r, heatmap-genes-interest, out.width = "1200px"}
# Prepare data for the heatmap
mat3 <- assay(vsd_limma)[filtered_without_genes$Ensembl_ID, ]
rownames(mat3) <- gene_info$gene_name[match(filtered_without_genes$Ensembl_ID, gene_info$Ensembl_ID)]
df <- as.data.frame(colData(vsd_limma)[, c("Affected", "OverallCategory")])

# Set up color palette
color_palette <- colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(50)

# Specify the number of row clusters
num_row_clusters <- 3

png("output/all-samples-analysis/genes_of_interest_heatmap.png", width = 12, height = 10, units = "in", res = 1200)

draw(ComplexHeatmap::pheatmap(
  mat = mat3,
  color = colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(50),
  annotation_col = df,
  annotation_colors = ann_colors3,
  fontsize = 6,
  angle_col = c("0"),
  cellheight = 10, # Set cell height
  cellwidth = 24, # Set cell width
  border_color = "black", # Black borders around heatmap cells
  # cutree_rows = num_row_clusters,  # Number of row clusters
  heatmap_legend_param = list(
    title = "Matrix"
  )
))

dev.off()
```


## Additional Interesting Genes

```{r, additonal-plot-counts-genes-interest}
# Create an empty list to store the results for each gene
gene_results_list <- list()

# Create an empty dataframe to store all counts data for plotting
gi_all_counts <- data.frame()

# Loop through each gene to calculate and plot counts
for (ensembl_id in filtered_with_only_genes$Ensembl_ID) {
  d <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  dp <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  gene_name <- filtered_with_only_genes$gene_name[filtered_with_only_genes$Ensembl_ID == ensembl_id]

  # Calculate the mean and standard deviation of counts within each condition
  d_stats <- d %>%
    group_by(Affected) %>%
    summarise(
      mean_count = mean(count),
      sd_count = sd(count)
    )

  # Merge statistics back with the data
  d <- merge(d, d_stats, by = "Affected")

  # Create a temporary dataframe to store results for this gene
  temp_gene_df <- data.frame(
    Patient = rownames(d),
    stringsAsFactors = FALSE
  )

  # Calculate Z-scores and determine regulation status
  regulation_status <- sapply(1:nrow(d), function(i) {
    z_score <- (d$count[i] - d$mean_count[i]) / d$sd_count[i]

    # Determine regulation status based on Z-score
    if (z_score > 1) {
      return("Upregulated")
    } else if (z_score < -1) {
      return("Downregulated")
    } else {
      return("Neutral")
    }
  })

  # Add the regulation status to the temporary dataframe
  temp_gene_df[[gene_name]] <- regulation_status

  # Merge the temporary dataframe with the results list
  if (length(gene_results_list) == 0) {
    gene_results_list[[1]] <- temp_gene_df
  } else {
    gene_results_list[[1]] <- merge(gene_results_list[[1]], temp_gene_df, by = "Patient", all = TRUE)
  }

  # Add the gene name to the dp dataframe
  dp$Gene <- gene_name
  dp$Ensembl_ID <- ensembl_id
  dp$SampleID <- rownames(dp)

  # Combine dp with all_counts dataframe
  gi_all_counts <- rbind(gi_all_counts, dp)

  # Generate the boxplot
  gene_plot <- ggboxplot(dp,
    x = "Affected", y = "count", add = "jitter",
    color = "Affected", palette = c("red", "navy"),
    title = gene_name
  ) +
    geom_text_repel(aes(label = rownames(dp))) +
    scale_color_manual(
      name = "Affected Status",
      labels = c("Affected", "Unaffected"),
      values = c("red", "navy")
    )
  print(gene_plot) # Ensure each plot is printed during the loop
  ggsave(
    filename = paste0(gene_name, "-plot-counts.png"),
    path = "output/all-samples-analysis/batch-correction-limma/plot-counts/slc4a1-genes-of-interest",
    plot = gene_plot, dpi = 450, create.dir = TRUE
  )
}

# Create the faceted plot
faceted_plot <- ggplot(gi_all_counts, aes(x = Affected, y = count, color = Affected)) +
  geom_boxplot(alpha = 0.35) +
  geom_jitter(width = 0.2, size = .45) + # Adjust size of the dots
  geom_text_repel(aes(label = SampleID),
    size = 2,
    max.overlaps = Inf, force = 10, color = "black",
    segment.color = "gray",
    min.segment.length = 0,
    point.padding = 0.1
  ) + # Add labels to the dots
  facet_wrap(~Gene, scales = "free_y") +
  theme_bw() +
  labs(title = "Gene Expression Counts by Affected Status", x = "Affected Status", y = "Count") +
  scale_color_manual(values = c("red", "navy")) +
  theme(
    legend.position = "bottom",
    plot.margin = margin(10, 10, 10, 10),
    strip.text = element_text(size = 6), # Adjust facet label text size
    plot.title = element_text(size = 10),
    axis.title = element_text(size = 10),
    axis.text = element_text(size = 6),
    panel.spacing = unit(.35, "lines") # Add space between facets
  ) +
  coord_cartesian(clip = "off") # Ensure labels are not clipped


faceted_plot

# Save the faceted plot
ggsave(
  filename = "faceted_slc4a1_genes_of_interest_plot_counts.png",
  path = "output/all-samples-analysis/batch-correction-limma/plot-counts/slc4a1-genes-of-interest",
  plot = faceted_plot, dpi = 2200, create.dir = TRUE
)

# Convert the list to a dataframe
gene_results_df <- gene_results_list[[1]]

file_name <- "output/all-samples-analysis/slc4a1_genes_of_interest_plot_counts_signals.csv"
write.csv(gene_results_df, file_name, row.names = FALSE)
```

Below is a heatmap highlighting the expression of our genes of interest across batch, disease group, and affected status.

```{r, heatmap-additional-genes-interest, out.width = "1200px"}
# Prepare data for the heatmap
mat4 <- assay(vsd_limma)[filtered_with_only_genes$Ensembl_ID, ]
rownames(mat4) <- gene_info$gene_name[match(filtered_with_only_genes$Ensembl_ID, gene_info$Ensembl_ID)]
df <- as.data.frame(colData(vsd_limma)[, c("Affected", "OverallCategory")])

# Set up color palette
color_palette <- colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(50)

# Specify the number of row clusters
num_row_clusters <- 3

png("output/all-samples-analysis/slc4a1_genes_of_interest_heatmap.png", width = 14, height = 10, units = "in", res = 1200)

draw(ComplexHeatmap::pheatmap(
  mat = mat4,
  color = colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(50),
  annotation_col = df,
  annotation_colors = ann_colors3,
  fontsize = 6,
  angle_col = c("0"),
  cellheight = 10, # Set cell height
  cellwidth = 24, # Set cell width
  border_color = "black", # Black borders around heatmap cells
  # cutree_rows = num_row_clusters,  # Number of row clusters
  heatmap_legend_param = list(
    title = "Matrix"
  )
))

dev.off()
```

## Only MADD Genes

```{r, generate-plot-counts-genes-interest-madd}
# Create an empty list to store the results for each gene
gene_results_list <- list()

# Create an empty dataframe to store all counts data for plotting
gi_all_counts <- data.frame()

# Loop through each gene to calculate and plot counts
for (ensembl_id in filtered_with_only_madd_genes$Ensembl_ID) {
  d <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  dp <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  gene_name <- filtered_with_only_madd_genes$gene_name[filtered_with_only_madd_genes$Ensembl_ID == ensembl_id]

  # Calculate the mean and standard deviation of counts within each condition
  d_stats <- d %>%
    group_by(Affected) %>%
    summarise(
      mean_count = mean(count),
      sd_count = sd(count)
    )

  # Merge statistics back with the data
  d <- merge(d, d_stats, by = "Affected")

  # Create a temporary dataframe to store results for this gene
  temp_gene_df <- data.frame(
    Patient = rownames(d),
    stringsAsFactors = FALSE
  )

  # Calculate Z-scores and determine regulation status
  regulation_status <- sapply(1:nrow(d), function(i) {
    z_score <- (d$count[i] - d$mean_count[i]) / d$sd_count[i]

    # Determine regulation status based on Z-score
    if (z_score > 1) {
      return("Upregulated")
    } else if (z_score < -1) {
      return("Downregulated")
    } else {
      return("Neutral")
    }
  })

  # Add the regulation status to the temporary dataframe
  temp_gene_df[[gene_name]] <- regulation_status

  # Merge the temporary dataframe with the results list
  if (length(gene_results_list) == 0) {
    gene_results_list[[1]] <- temp_gene_df
  } else {
    gene_results_list[[1]] <- merge(gene_results_list[[1]], temp_gene_df, by = "Patient", all = TRUE)
  }

  # Add the gene name to the dp dataframe
  dp$Gene <- gene_name
  dp$Ensembl_ID <- ensembl_id
  dp$SampleID <- rownames(dp)

  # Combine dp with all_counts dataframe
  gi_all_counts <- rbind(gi_all_counts, dp)

  # Generate the boxplot
  gene_plot <- ggboxplot(dp,
    x = "Affected", y = "count", add = "jitter",
    color = "Affected", palette = c("red", "navy"),
    title = gene_name
  ) +
    geom_text_repel(aes(label = rownames(dp))) +
    scale_color_manual(
      name = "Affected Status",
      labels = c("Affected", "Unaffected"),
      values = c("red", "navy")
    )
  print(gene_plot) # Ensure each plot is printed during the loop
  ggsave(
    filename = paste0(gene_name, "-plot-counts.png"),
    path = "output/all-samples-analysis/batch-correction-limma/plot-counts/madd-genes-of-interest",
    plot = gene_plot, dpi = 450, create.dir = TRUE
  )
}

# Create the faceted plot
faceted_plot <- ggplot(gi_all_counts, aes(x = Affected, y = count, color = Affected)) +
  geom_boxplot(alpha = 0.35) +
  geom_jitter(width = 0.2, size = .45) + # Adjust size of the dots
  geom_text_repel(aes(label = SampleID),
    size = 2,
    max.overlaps = Inf, force = 10, color = "black",
    segment.color = "gray",
    min.segment.length = 0,
    point.padding = 0.1
  ) + # Add labels to the dots
  facet_wrap(~Gene, scales = "free_y") +
  theme_bw() +
  labs(title = "Gene Expression Counts by Affected Status", x = "Affected Status", y = "Count") +
  scale_color_manual(values = c("red", "navy")) +
  theme(
    legend.position = "bottom",
    plot.margin = margin(10, 10, 10, 10),
    strip.text = element_text(size = 6), # Adjust facet label text size
    plot.title = element_text(size = 10),
    axis.title = element_text(size = 10),
    axis.text = element_text(size = 6),
    panel.spacing = unit(.35, "lines") # Add space between facets
  ) +
  coord_cartesian(clip = "off") # Ensure labels are not clipped


faceted_plot

# Save the faceted plot
ggsave(
  filename = "faceted_madd_genes_of_interest_plot_counts.png",
  path = "output/all-samples-analysis/batch-correction-limma/plot-counts/madd-genes-of-interest",
  plot = faceted_plot, dpi = 2200, create.dir = TRUE
)

# Convert the list to a dataframe
gene_results_df <- gene_results_list[[1]]

file_name <- "output/all-samples-analysis/genes_of_interest_plot_counts_signals.csv"
write.csv(gene_results_df, file_name, row.names = FALSE)
```

Below is a heatmap highlighting the expression of our genes of interest across batch, disease group, and affected status.

```{r, heatmap-additional-genes-interest-madd, out.width = "1200px"}
# Prepare data for the heatmap
mat5 <- assay(vsd_limma)[filtered_with_only_madd_genes$Ensembl_ID, ]
rownames(mat5) <- gene_info$gene_name[match(filtered_with_only_madd_genes$Ensembl_ID, gene_info$Ensembl_ID)]
df <- as.data.frame(colData(vsd_limma)[, c("Affected", "OverallCategory")])

# Set up color palette
color_palette <- colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(50)

# Specify the number of row clusters
num_row_clusters <- 3

png("output/all-samples-analysis/madd_genes_of_interest_heatmap.png", width = 14, height = 8, units = "in", res = 1200)

draw(ComplexHeatmap::pheatmap(
  mat = mat5,
  color = colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(50),
  annotation_col = df,
  annotation_colors = ann_colors3,
  fontsize = 6,
  angle_col = c("0"),
  cellheight = 10, # Set cell height
  cellwidth = 24, # Set cell width
  border_color = "black", # Black borders around heatmap cells
  # cutree_rows = num_row_clusters,  # Number of row clusters
  heatmap_legend_param = list(
    title = "Matrix"
  )
))

dev.off()
```


## Only MITO Genes

```{r, generate-plot-counts-genes-interest-mito}
# Create an empty list to store the results for each gene
gene_results_list <- list()

# Create an empty dataframe to store all counts data for plotting
gi_all_counts <- data.frame()

# Loop through each gene to calculate and plot counts
for (ensembl_id in filtered_with_only_mito_genes$Ensembl_ID) {
  d <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  dp <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  gene_name <- filtered_with_only_mito_genes$gene_name[filtered_with_only_mito_genes$Ensembl_ID == ensembl_id]

  # Calculate the mean and standard deviation of counts within each condition
  d_stats <- d %>%
    group_by(Affected) %>%
    summarise(
      mean_count = mean(count),
      sd_count = sd(count)
    )

  # Merge statistics back with the data
  d <- merge(d, d_stats, by = "Affected")

  # Create a temporary dataframe to store results for this gene
  temp_gene_df <- data.frame(
    Patient = rownames(d),
    stringsAsFactors = FALSE
  )

  # Calculate Z-scores and determine regulation status
  regulation_status <- sapply(1:nrow(d), function(i) {
    z_score <- (d$count[i] - d$mean_count[i]) / d$sd_count[i]

    # Determine regulation status based on Z-score
    if (z_score > 1) {
      return("Upregulated")
    } else if (z_score < -1) {
      return("Downregulated")
    } else {
      return("Neutral")
    }
  })

  # Add the regulation status to the temporary dataframe
  temp_gene_df[[gene_name]] <- regulation_status

  # Merge the temporary dataframe with the results list
  if (length(gene_results_list) == 0) {
    gene_results_list[[1]] <- temp_gene_df
  } else {
    gene_results_list[[1]] <- merge(gene_results_list[[1]], temp_gene_df, by = "Patient", all = TRUE)
  }

  # Add the gene name to the dp dataframe
  dp$Gene <- gene_name
  dp$Ensembl_ID <- ensembl_id
  dp$SampleID <- rownames(dp)

  # Combine dp with all_counts dataframe
  gi_all_counts <- rbind(gi_all_counts, dp)

  # Generate the boxplot
  gene_plot <- ggboxplot(dp,
    x = "Affected", y = "count", add = "jitter",
    color = "Affected", palette = c("red", "navy"),
    title = gene_name
  ) +
    geom_text_repel(aes(label = rownames(dp))) +
    scale_color_manual(
      name = "Affected Status",
      labels = c("Affected", "Unaffected"),
      values = c("red", "navy")
    )
  print(gene_plot) # Ensure each plot is printed during the loop
  ggsave(
    filename = paste0(gene_name, "-plot-counts.png"),
    path = "output/all-samples-analysis/batch-correction-limma/plot-counts/mito-genes-of-interest",
    plot = gene_plot, dpi = 450, create.dir = TRUE
  )
}

# Create the faceted plot
faceted_plot <- ggplot(gi_all_counts, aes(x = Affected, y = count, color = Affected)) +
  geom_boxplot(alpha = 0.35) +
  geom_jitter(width = 0.2, size = .45) + # Adjust size of the dots
  geom_text_repel(aes(label = SampleID),
    size = 2,
    max.overlaps = Inf, force = 10, color = "black",
    segment.color = "gray",
    min.segment.length = 0,
    point.padding = 0.1
  ) + # Add labels to the dots
  facet_wrap(~Gene, scales = "free_y") +
  theme_bw() +
  labs(title = "Gene Expression Counts by Affected Status", x = "Affected Status", y = "Count") +
  scale_color_manual(values = c("red", "navy")) +
  theme(
    legend.position = "bottom",
    plot.margin = margin(10, 10, 10, 10),
    strip.text = element_text(size = 6), # Adjust facet label text size
    plot.title = element_text(size = 10),
    axis.title = element_text(size = 10),
    axis.text = element_text(size = 6),
    panel.spacing = unit(.35, "lines") # Add space between facets
  ) +
  coord_cartesian(clip = "off") # Ensure labels are not clipped


faceted_plot

# Save the faceted plot
ggsave(
  filename = "faceted_madd_genes_of_interest_plot_counts.png",
  path = "output/all-samples-analysis/batch-correction-limma/plot-counts/mito-genes-of-interest",
  plot = faceted_plot, dpi = 2200, create.dir = TRUE
)

# Convert the list to a dataframe
gene_results_df <- gene_results_list[[1]]

file_name <- "output/all-samples-analysis/mito_genes_of_interest_plot_counts_signals.csv"
write.csv(gene_results_df, file_name, row.names = FALSE)
```

Below is a heatmap highlighting the expression of our genes of interest across batch, disease group, and affected status.

```{r, heatmap-additional-genes-interest-mito, out.width = "1200px"}
# Prepare data for the heatmap
mat6 <- assay(vsd_limma)[filtered_with_only_mito_genes$Ensembl_ID, ]
rownames(mat6) <- gene_info$gene_name[match(filtered_with_only_mito_genes$Ensembl_ID, gene_info$Ensembl_ID)]
df <- as.data.frame(colData(vsd_limma)[, c("Affected", "OverallCategory")])

# Set up color palette
color_palette <- colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(50)

# Specify the number of row clusters
num_row_clusters <- 3

png("output/all-samples-analysis/mito_genes_of_interest_heatmap.png", width = 14, height = 8, units = "in", res = 1200)

draw(ComplexHeatmap::pheatmap(
  mat = mat6,
  color = colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(50),
  annotation_col = df,
  annotation_colors = ann_colors3,
  fontsize = 6,
  angle_col = c("0"),
  cellheight = 10, # Set cell height
  cellwidth = 24, # Set cell width
  border_color = "black", # Black borders around heatmap cells
  # cutree_rows = num_row_clusters,  # Number of row clusters
  heatmap_legend_param = list(
    title = "Matrix"
  )
))

dev.off()
```

## Significant Genes Plot Counts

```{r, generate-plot-counts-genes-significant}
# Create an empty list to store the results for each gene
results_list <- list()

# Create an empty dataframe to store all counts data for plotting
all_counts <- data.frame()

# Loop through each gene to calculate and plot counts
for (ensembl_id in res_aff_vs_unaff_df_genename_padj05_lfc1$Ensembl_ID) {
  dp <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  d <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  gene_name <- res_aff_vs_unaff_df_genename_padj05_lfc1$gene_name[res_aff_vs_unaff_df_genename_padj05_lfc1$Ensembl_ID == ensembl_id]

  # Calculate the mean and standard deviation of counts within each condition
  d_stats <- d %>%
    group_by(Affected) %>%
    summarise(
      mean_count = mean(count),
      sd_count = sd(count)
    )

  # Merge statistics back with the data
  d <- merge(d, d_stats, by = "Affected")

  # Create a temporary dataframe to store results for this gene
  temp_df <- data.frame(
    Patient = rownames(d),
    stringsAsFactors = FALSE
  )

  # Calculate Z-scores and determine regulation status
  regulation_status <- sapply(1:nrow(d), function(i) {
    if (is.na(d$sd_count[i]) || d$sd_count[i] == 0) {
      return("Neutral")
    }

    z_score <- (d$count[i] - d$mean_count[i]) / d$sd_count[i]

    # Determine regulation status based on Z-score
    if (is.na(z_score)) {
      return("Neutral")
    } else if (z_score > 1) {
      return("Upregulated")
    } else if (z_score < -1) {
      return("Downregulated")
    } else {
      return("Neutral")
    }
  })

  # Add the regulation status to the temporary dataframe
  temp_df[[gene_name]] <- regulation_status

  # Merge the temporary dataframe with the results list
  if (length(results_list) == 0) {
    results_list[[1]] <- temp_df
  } else {
    results_list[[1]] <- merge(results_list[[1]], temp_df, by = "Patient", all = TRUE)
  }

  # Add the gene name to the dp dataframe
  dp$Gene <- gene_name
  dp$Ensembl_ID <- ensembl_id
  dp$SampleID <- rownames(dp)

  # Combine dp with all_counts dataframe
  all_counts <- rbind(all_counts, dp)

  # Generate the boxplot
  ggplot_box <- ggboxplot(dp,
    x = "Affected", y = "count", add = "jitter",
    color = "Affected", palette = c("red", "navy"),
    title = gene_name
  ) +
    geom_text_repel(aes(label = rownames(dp))) +
    scale_color_manual(
      name = "Affected Status",
      labels = c("Affected", "Unaffected"),
      values = c("red", "navy")
    )
  print(ggplot_box) # Ensure each plot is printed during the loop
  ggsave(
    filename = paste0(gene_name, "-plot-counts.png"),
    path = "output/all-samples-analysis/batch-correction-limma/plot-counts/padj-05",
    plot = ggplot_box, dpi = 450, create.dir = TRUE
  )
}

# Create the faceted plot
faceted_plot <- ggplot(all_counts, aes(x = Affected, y = count, color = Affected)) +
  geom_boxplot(alpha = 0.4) +
  geom_jitter(width = 0.2, size = 1.25) + # Adjust size of the dots
  geom_text_repel(aes(label = SampleID),
    size = 2,
    max.overlaps = Inf, force = 10, color = "black",
    segment.color = "gray",
    min.segment.length = 0,
    point.padding = 0.1
  ) + # Add labels to the dots
  facet_wrap(~Gene, scales = "free_y") +
  theme_bw() +
  labs(title = "Gene Expression Counts by Affected Status", x = "Affected Status", y = "Count") +
  scale_color_manual(values = c("red", "navy")) +
  theme(
    legend.position = "bottom",
    plot.margin = margin(10, 10, 10, 10),
    strip.text = element_text(size = 8), # Adjust facet label text size
    plot.title = element_text(size = 14),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    panel.spacing = unit(1, "lines") # Add space between facets
  ) +
  coord_cartesian(clip = "off") # Ensure labels are not clipped


faceted_plot

# Save the faceted plot
ggsave(
  filename = "faceted_significant_degs_plot_counts.png",
  path = "output/all-samples-analysis/batch-correction-limma/plot-counts/padj-05",
  plot = faceted_plot, dpi = 1200, create.dir = TRUE
)

# Convert the list to a dataframe
results_df <- results_list[[1]]

file_name <- "output/all-samples-analysis/significant_plot_counts_signals.csv"
write.csv(results_df, file_name, row.names = FALSE)
```

## Heatmap of All Genes


```{r, heatmap-of-all}
all_genes <- unique(c(blood_genes, madd_genes, mito_genes, filtered_by_interest$gene_name, significant_data$name))

output_path <- "output/all-samples-analysis/"
file_name <- file.path(output_path, "all-genes-heatmap.png")

# Keep only specific genes
all_genes_data <- res_aff_vs_unaff_df_genename %>%
  filter(gene_name %in% all_genes)

# Prepare the heatmap data
all_mat <- assay(vsd_limma)[all_genes_data$Ensembl_ID, ]
rownames(all_mat) <- gene_info$gene_name[match(all_genes_data$Ensembl_ID, gene_info$Ensembl_ID)]
df_sub <- as.data.frame(colData(vsd_limma)[, c("Affected", "OverallCategory")])

png(file_name, width = 16, height = 26, units = "in", res = 1200)
draw(
  ComplexHeatmap::pheatmap(
    mat = all_mat,
    color = colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(50),
    annotation_col = df_sub,
    annotation_colors = ann_colors,
    fontsize = 6,
    angle_col = c("0"),
    cellheight = 10,
    cellwidth = 24,
    border_color = "black",
    heatmap_legend_param = list(title = "Matrix")
  )
)
dev.off()
```


### Save data

```{r, save-data}
save.image(file = "output/all-samples-analysis/all-condition-analysis.RData")
```

