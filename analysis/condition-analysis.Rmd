---
title: "Differential Gene Expression (DGE) Analysis"
output:
  workflowr::wflow_html:
    toc: true
    toc_depth: 3
    toc_float: true
    code_folding: hide
editor_options:
  chunk_output_type: console
---

```{r, setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# DGE Analysis Setup {.tabset}

Ensure you have all necessary libraries installed and load the helper code.

At a later date, `renv` will be integrated to ensure reproducibility of this analysis.

Use the below code to install these packages:


```
# Install packages from CRAN
install.packages(c("tidyverse", "RColorBrewer", "pheatmap", "gprofiler2", "plotly", "ggupset"))

# Install packages from Bioconductor
install.packages("BiocManager")
BiocManager::install(c("DESeq2", "genefilter", "limma", "biomaRt", "mygene"))
```

```{r, load libraries, warning = FALSE, message = FALSE}
library(tidyverse) # Available via CRAN
library(DESeq2) # Available via Bioconductor
library(RColorBrewer) # Available via CRAN
library(pheatmap) # Available via CRAN
library(genefilter) # Available via Bioconductor
library(limma) # Available via Bioconductor
library(gprofiler2) # Available via CRAN
library(biomaRt) # Available via Bioconductor
library(plotly) # Available via CRAN
library(ggpubr)
library(rmarkdown)
library(ggupset)
library(clusterProfiler)
library(DOSE)
library(org.Hs.eg.db) # Available via Bioconductor
library(UpSetR)
library(ggrepel)
```

```{r, include=FALSE}
source("code/helpers.R", local = knitr::knit_global())
# or sys.source("your-script.R", envir = knitr::knit_global())
```

## Data Import

We will be importing counts data from the star-salmon pipeline and our metadata 
for the project which is hosted on Box. This also ensures data is properly ordered by sample id.

```{r, import data}
counts <- read_tsv("data/star-salmon/salmon.merged.gene_counts_length_scaled.tsv")

# Import variants of interest
genes_of_interest <- read_csv("data/Patient_Genes_2024_03_05.csv")
genes_of_interest <- unique(genes_of_interest$Genes)
genes_of_interest <- genes_of_interest[!is.na(genes_of_interest)]

# Use first column (gene_id) for row names
counts <- data.frame(counts, row.names = 1)
counts$Ensembl_ID <- row.names(counts)
drop <- c("Ensembl_ID", "gene_name")
gene_info <- counts[, drop]
counts <- counts[, !(names(counts) %in% drop)] # remove both columns

# Import metadata
sample_metadata <- read_csv("data/MECFS_RNAseq_metadata_2024_03_05.csv")
row.names(sample_metadata) <- sample_metadata$ID

# Assuming counts is your counts dataframe and sample_metadata is your metadata dataframe
# Call the function with the appropriate column names
counts <- rename_counts_columns(counts, sample_metadata, "ID", "RNA_Samples_id")

# Check that data is ordered properly
sample_metadata <- check_order(sample_metadata = sample_metadata, counts = counts)

genes_biomart <- retrieve_gene_info(values = gene_info$Ensembl_ID, filters = "ensembl_gene_id_version")
```

## DESeq2 Analysis

```{r, start analysis}
sample_metadata$Family <- factor(sample_metadata$Family)
sample_metadata$Affected <- factor(sample_metadata$Affected)
sample_metadata$Batch <- factor(sample_metadata$Batch)
sample_metadata$Sex <- factor(sample_metadata$Sex)
sample_metadata$Ancestry <- factor(sample_metadata$Ancestry)
#sample_metadata$Disease <- factor(sample_metadata$Disease)
sample_metadata$Category <- factor(sample_metadata$Category)

# Account for Family later but batch is accounted for
# Accounting for another factor seems to be an issue.
dds <- DESeqDataSetFromMatrix(countData = round(counts), colData = sample_metadata, design = ~ Batch + Affected)

# Pre-filtering: Keep only rows that have at least 10 reads total
keep <- rowSums(counts(dds)) >= 10
dds <- dds[keep, ]

# Remove male samples
male_samples <- c("LW001994", "LW001984", "LW001985")
# Create a logical vector to index the columns you want to keep
female_samples <- !(colnames(dds) %in% male_samples)
dds_female <- dds[, female_samples]

# Run DESeq function
dds <- DESeq(dds)
dds_female <- DESeq(dds_female)

# Normalize gene counts for differences in seq. depth/global differences
counts_norm <- counts(dds, normalized = TRUE)
counts_norm_female <- counts(dds_female, normalized = TRUE)
```

### Data transformation and visualization

Perform count data transformation by variance stabilizing transformation (vst) on normalized counts.

```{r, vsd}
vsd <- vst(dds, blind = FALSE)
vsd_female <- vst(dds_female, blind = FALSE)
```

### Batch correction with limma

```{r, limma}
counts_vst <- assay(vsd)
write.csv(counts_vst, file = "output/counts_vst.csv")
mm <- model.matrix(~ Batch + Affected, colData(vsd))

counts_vst_limma <- limma::removeBatchEffect(counts_vst, batch = vsd$Batch, design = mm)

write.csv(counts_vst_limma, file = "output/counts_vst_limma.csv")

vsd_limma <- vsd
assay(vsd_limma) <- counts_vst_limma

# For just female samples
counts_vst_female <- assay(vsd_female)
write.csv(counts_vst_female, file = "output/counts_vst_female.csv")
mm <- model.matrix(~ Batch + Affected, colData(vsd_female))

counts_vst_limma_female <- limma::removeBatchEffect(counts_vst_female, batch = vsd_female$Batch, design = mm)

write.csv(counts_vst_limma_female, file = "output/counts_vst_limma_female.csv")

vsd_limma_female <- vsd_female
assay(vsd_limma_female) <- counts_vst_limma_female
```

### Sample distances heatmap

```{r, sample-dist-heatmap}
sample_dists <- dist(t(assay(vsd_limma_female)))
sample_dist_matrix <- as.matrix(sample_dists)
rownames(sample_dist_matrix) <- paste(vsd_limma_female$Batch, vsd_limma_female$Affected, sep = " | ")
colnames(sample_dist_matrix) <- paste(vsd_limma_female$ID, vsd_limma_female$Affected, sep = " | ")

colors <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)

pheatmap(sample_dist_matrix, clustering_distance_rows = sample_dists, clustering_distance_cols = sample_dists, col = colors)
```


```{r, sample-dist-heatmap-all}
sample_dists_all <- dist(t(assay(vsd_limma)))
sample_dist_matrix_all <- as.matrix(sample_dists_all)
rownames(sample_dist_matrix_all) <- paste(vsd_limma$Batch, vsd_limma$Affected, sep = " | ")
colnames(sample_dist_matrix_all) <- paste(vsd_limma$ID, vsd_limma$Affected, sep = " | ")
colors <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)

pheatmap(sample_dist_matrix_all, clustering_distance_rows = sample_dists_all, clustering_distance_cols = sample_dists_all, col = colors)
```

### Principal Components Analysis

Our below PCA shows that there does not seem to be a batch-related effect occurring after using limma. However, we can see that our 3 male samples are grouping. Given this knowledge, removing them from downstream analyses is the best option.

```{r, principal-components-analysis-all}
pca_data_all <- plotPCA(vsd_limma, intgroup = c("Batch", "Affected", "Sex"), returnData = TRUE)
percent_var_all <- round(100 * attr(pca_data_all, "percentVar"))

ggplot(pca_data_all, aes(PC1, PC2)) +
  geom_point(aes(colour = Affected, fill = Sex, shape = Batch), size = 4) +
    scale_shape_manual(values = c(21, 22, 23) )+
  scale_fill_manual(values = c("white","gray"))+
  scale_color_manual(values=c("blue","red"))+
  geom_text(aes(label = name),
    data = subset(pca_data_all, PC2 < -18 | PC1 < -30 ),
    vjust = -1, hjust = 0.5, size = 2.5
  ) +
  xlab(paste0("PC1: ", percent_var_all[1], "% variance")) +
  ylab(paste0("PC2: ", percent_var_all[2], "% variance")) +
  coord_fixed()
```

Below is PCA with only female samples.

```{r, principal-components-analysis-female}
pca_data_female <- plotPCA(vsd_limma_female, intgroup = c("Batch", "Affected"), returnData = TRUE)
percent_var_female <- round(100 * attr(pca_data_female, "percentVar"))

ggplot(pca_data_female, aes(PC1, PC2)) +
  geom_point(aes(shape = Batch, colour = Affected), size = 4) +
   scale_color_manual(values=c("blue","red")) +
  geom_text(aes(label = name),
    data = subset(pca_data_female, PC2 < -15 | PC1 > 25 | PC1 < -40 ),
    vjust = -1, hjust = 0.5, size = 2.5
  ) +
  xlab(paste0("PC1: ", percent_var_female[1], "% variance")) +
  ylab(paste0("PC2: ", percent_var_female[2], "% variance")) +
  coord_fixed()
```

```{r, principal-components-analysis-ancestry}
pca_data_anc <- plotPCA(vsd_limma_female, intgroup = c("Batch", "Affected", "Ancestry"), returnData = TRUE)
percent_var_anc <- round(100 * attr(pca_data_anc, "percentVar"))

ggplot(pca_data_anc, aes(PC1, PC2)) +
  geom_point(aes(colour = Affected, fill = Ancestry, shape = Batch), size = 4) +
    scale_shape_manual(values = c(21, 22, 23) )+
  scale_fill_manual(values = c("greenyellow","khaki1"))+
  scale_color_manual(values=c("blue","red"))+
  geom_text(aes(label = name),
    data = subset(pca_data_anc, Ancestry == "Black" ),
    vjust = -1, hjust = 0.5, size = 2.5
  ) +
  xlab(paste0("PC1: ", percent_var_anc[1], "% variance")) +
  ylab(paste0("PC2: ", percent_var_anc[2], "% variance")) +
  coord_fixed()
```

### Heatmap of all genes, top 50  & top 100 genes

This is a heatmap for all genes across only female samples.

```{r, all-heatmap, out.height="570px", out.width ="800px"}
# Specify annotation colors by columns
# Use RColorBrewer::brewer.pal(n=10, name="Set1")
disease_colors <- c(
  "Cryohydrocytosis" = "#8DD3C7",
  "Gitelman Syndrome" = "#FFFFB3",
  "Gitelman Syndrome & Thyrotoxic Periodic Paralysis" = "#BEBADA",
  "Glycogen Storage Disease" = "#FB8072",
  "Immunodeficiency/Autoinflammatory Diseases" = "#80B1D3",
  "Immunodeficiency/Autoinflammatory Diseases & Mitochondrial Disorder" = "#FDB462",
  "Mitochondrial Disorder" = "#B3DE69",
  "N/A" = "#FCCDE5",
  "Neurological/Neuromuscular Disorders" = "#D9D9D9",
  "Stromme syndrome" = "#BC80BD",
  "Thyrotoxic Periodic Paralysis" = "#CCEBC5",
  "Unknown" = "#FFED6F"
)

category_colors <- c(
  "Metabolism" = "#B3DE69",
  "Immune" = "#FFFFB3",
  "Channelopathies" = "#BEBADA",
  "Misc:Mitochondria" = "#FB8072",
  "Misc:Myosin family" = "#80B1D3",
  "Misc:Ciliopathy" = "#FCCDE5",
  "None" = "#FDB462"
)


# Specify colors
ann_colors = list(
    Batch = c(B1 = "purple", B2 = "firebrick", B3 ="yellow"),
    Affected = c(Yes = "green", No = "navy"),
    Disease = disease_colors,
    Category = category_colors
)

ann_colors2 = list(
    Batch = c(B1 = "purple", B2 = "firebrick", B3 ="yellow"),
    Affected = c(Yes = "green", No = "navy"),
    Category = category_colors,
    Disease = disease_colors
)

all_genes <- order(-rowVars(assay(vsd_limma_female)))
mat <- assay(vsd_limma_female)[all_genes, ]
mat <- mat - rowMeans(mat)
df <- as.data.frame(colData(vsd)[, c("Batch", "Affected", "Disease Group")])
#pheatmap(mat, annotation_col = df, annotation_colors = ann_colors, fontsize = 5)
```


This is a heatmap of the top 50 genes with the highest variance across only female samples.

```{r, top50-heatmap, out.height="570px", out.width ="800px"}
top_var_genes <- head(order(-rowVars(assay(vsd_limma_female))), 50)
mat <- assay(vsd_limma_female)[top_var_genes, ]
mat <- mat - rowMeans(mat)
df <- as.data.frame(colData(vsd_limma_female)[, c("Batch", "Affected", "Disease Group")])

ensembl_to_gene <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)

# Get the current row names of the matrix 'mat'
current_ensembl_ids <- rownames(mat)

# Find the corresponding gene names for the Ensembl IDs
new_row_names <- ensembl_to_gene[current_ensembl_ids]

# Set the new row names for the matrix 'mat'
rownames(mat) <- new_row_names

pheatmap(mat, annotation_col = df, annotation_colors = ann_colors, fontsize = 5)
```


This is a heatmap of the top 50 genes with the highest variance across all samples.

```{r, top50-heatmap-all, out.height="570px", out.width ="800px"}
top_var_genes_all <- head(order(-rowVars(assay(vsd_limma))), 50)
mat_all <- assay(vsd_limma)[top_var_genes_all, ]
mat_all <- mat_all - rowMeans(mat_all)
df_all <- as.data.frame(colData(vsd_limma)[, c("Batch", "Affected", "Category")])
df_affcat <- as.data.frame(colData(vsd_limma)[, c("Affected", "Category")])

ensembl_to_gene <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)

# Get the current row names of the matrix 'mat'
current_ensembl_ids_all <- rownames(mat_all)

# Find the corresponding gene names for the Ensembl IDs
new_row_names_all <- ensembl_to_gene[current_ensembl_ids_all]

# Set the new row names for the matrix 'mat'
rownames(mat_all) <- new_row_names_all

pheatmap(mat_all, annotation_col = df_all, annotation_colors = ann_colors, fontsize = 5)

pheatmap(mat_all, annotation_col = df_affcat, annotation_colors = ann_colors2, fontsize = 5)
```

This is a heatmap of the top 100 genes with the highest variance across only female samples. 
```{r, top100-heatmap, out.width = "1200px"}
top_var_genes_100 <- head(order(-rowVars(assay(vsd_limma_female))), 100)
mat_100 <- assay(vsd_limma_female)[top_var_genes_100, ]
mat_100 <- mat_100 - rowMeans(mat_100)
df_100 <- as.data.frame(colData(vsd_limma_female)[, c("Batch", "Affected", "Category")])

ensembl_to_gene <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)

# Get the current row names of the matrix 'mat'
current_ensembl_ids <- rownames(mat_100)

# Find the corresponding gene names for the Ensembl IDs
new_row_names <- ensembl_to_gene[current_ensembl_ids]

# Set the new row names for the matrix 'mat'
rownames(mat_100) <- new_row_names

pheatmap(mat_100, annotation_col = df_100, annotation_colors = ann_colors2, fontsize = 6)
```

This is a heatmap of the top 100 genes with the highest variance across all samples. 
```{r, top100-heatmap-all, out.width = "1200px"}
top_var_genes_100_all <- head(order(-rowVars(assay(vsd_limma))), 100)
mat_100_all <- assay(vsd_limma)[top_var_genes_100_all, ]
mat_100_all <- mat_100_all - rowMeans(mat_100_all)
df_100_all <- as.data.frame(colData(vsd_limma)[, c("Batch", "Affected", "Category")])

ensembl_to_gene <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)

# Get the current row names of the matrix 'mat'
current_ensembl_ids_100_all <- rownames(mat_100_all)

# Find the corresponding gene names for the Ensembl IDs
new_row_names_100_all <- ensembl_to_gene[current_ensembl_ids_100_all]

# Set the new row names for the matrix 'mat'
rownames(mat_100_all) <- new_row_names_100_all

pheatmap(mat_100_all, annotation_col = df_100_all, annotation_colors = ann_colors2, fontsize = 6)
```

### Comparison/Contrast of Affected_Yes_vs_No 

```{r}
res_aff_vs_unaff <- results(dds_female, contrast = c("Affected", "Yes", "No"))
res_aff_vs_unaff_df <- process_and_save_results(res_aff_vs_unaff, 
                                                "output/res_aff_vs_unaff.csv")
res_aff_vs_unaff_df <- arrange(res_aff_vs_unaff_df, padj)
res_aff_vs_unaff_df_05 <- subset(res_aff_vs_unaff_df, padj < 0.05)

summary(res_aff_vs_unaff)

res_aff_vs_unaff_m <- results(dds, contrast = c("Affected", "Yes", "No"))
res_aff_vs_unaff_df_m <- process_and_save_results(res_aff_vs_unaff_m, 
                                                "output/res_aff_vs_unaff_m.csv")
res_aff_vs_unaff_df_m <- arrange(res_aff_vs_unaff_df_m, padj)
res_aff_vs_unaff_df_05_m <- subset(res_aff_vs_unaff_df_m, padj < 0.05)
res_aff_vs_unaff_df_1_m <- subset(res_aff_vs_unaff_df_m, padj < 0.05)

summary(res_aff_vs_unaff_m)
```

```{r, top-100-genes-deseq-female, out.height="570px", out.width ="800px"}
topgenes_byensemblid <- head(rownames(res_aff_vs_unaff_df), 100)
topgenes_aff_vs_unaff_05 <- assay(vsd_limma_female)[topgenes_byensemblid, ]
topgenes_aff_vs_unaff_05 <- topgenes_aff_vs_unaff_05 - rowMeans(topgenes_aff_vs_unaff_05)

ensembl_to_gene <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)

# Get the current row names of the matrix 'mat'
current_ensembl_ids <- rownames(topgenes_aff_vs_unaff_05)

# Find the corresponding gene names for the Ensembl IDs
new_row_names <- ensembl_to_gene[current_ensembl_ids]

# Set the new row names for the matrix 'mat'
rownames(topgenes_aff_vs_unaff_05) <- new_row_names

topgenes_aff_vs_unaff_05 <- topgenes_aff_vs_unaff_05[order(row.names(topgenes_aff_vs_unaff_05)), ]

df <- colData(vsd_limma_female) %>% as.data.frame() %>% dplyr::select(Category)
pheatmap(topgenes_aff_vs_unaff_05, annotation_col = df, annotation_colors = ann_colors2, fontsize = 3)
```

```{r, top-100-genes-deseq-all, out.height="570px", out.width ="800px"}
topgenes_byensemblid_m <- head(rownames(res_aff_vs_unaff_df_m), 100)
topgenes_aff_vs_unaff_05_m <- assay(vsd_limma)[topgenes_byensemblid_m, ]
topgenes_aff_vs_unaff_05_m <- topgenes_aff_vs_unaff_05_m - rowMeans(topgenes_aff_vs_unaff_05_m)

ensembl_to_gene_m <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)

# Get the current row names of the matrix 'mat'
current_ensembl_ids_m <- rownames(topgenes_aff_vs_unaff_05_m)

# Find the corresponding gene names for the Ensembl IDs
new_row_names_m <- ensembl_to_gene_m[current_ensembl_ids_m]

# Set the new row names for the matrix 'mat'
rownames(topgenes_aff_vs_unaff_05_m) <- new_row_names_m

topgenes_aff_vs_unaff_05_m <- topgenes_aff_vs_unaff_05_m[order(row.names(topgenes_aff_vs_unaff_05_m)), ]

df_m <- as.data.frame(colData(vsd_limma)[, c("Affected", "Category")])
pheatmap(topgenes_aff_vs_unaff_05_m, annotation_col = df_m, annotation_colors = ann_colors2, fontsize = 3)
```

```{r, top-50-genes-deseq-all, out.height="570px", out.width ="800px"}
topgenes_byensemblid_m <- head(rownames(res_aff_vs_unaff_df_m), 50)
topgenes_aff_vs_unaff_05_m <- assay(vsd_limma)[topgenes_byensemblid_m, ]
topgenes_aff_vs_unaff_05_m <- topgenes_aff_vs_unaff_05_m - rowMeans(topgenes_aff_vs_unaff_05_m)

ensembl_to_gene_m <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)

# Get the current row names of the matrix 'mat'
current_ensembl_ids_m <- rownames(topgenes_aff_vs_unaff_05_m)

# Find the corresponding gene names for the Ensembl IDs
new_row_names_m <- ensembl_to_gene_m[current_ensembl_ids_m]

# Set the new row names for the matrix 'mat'
rownames(topgenes_aff_vs_unaff_05_m) <- new_row_names_m

topgenes_aff_vs_unaff_05_m <- topgenes_aff_vs_unaff_05_m[order(row.names(topgenes_aff_vs_unaff_05_m)), ]

df_m <- df <- colData(vsd_limma) %>% as.data.frame() %>% dplyr::select(Affected, Family, Category)
pheatmap(topgenes_aff_vs_unaff_05_m, annotation_col = df_m, annotation_colors = ann_colors2, fontsize = 5)
```


```{r, top-200-genes-deseq-all, out.height="570px", out.width ="800px"}
topgenes_byensemblid_m <- head(rownames(res_aff_vs_unaff_df_m), 200)
topgenes_aff_vs_unaff_05_m <- assay(vsd_limma)[topgenes_byensemblid_m, ]
topgenes_aff_vs_unaff_05_m <- topgenes_aff_vs_unaff_05_m - rowMeans(topgenes_aff_vs_unaff_05_m)

ensembl_to_gene_m <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)

# Get the current row names of the matrix 'mat'
current_ensembl_ids_m <- rownames(topgenes_aff_vs_unaff_05_m)

# Find the corresponding gene names for the Ensembl IDs
new_row_names_m <- ensembl_to_gene_m[current_ensembl_ids_m]

# Set the new row names for the matrix 'mat'
rownames(topgenes_aff_vs_unaff_05_m) <- new_row_names_m

topgenes_aff_vs_unaff_05_m <- topgenes_aff_vs_unaff_05_m[order(row.names(topgenes_aff_vs_unaff_05_m)), ]

df_m <- as.data.frame(colData(vsd_limma)[, c("Affected", "Category")])
pheatmap(topgenes_aff_vs_unaff_05_m, annotation_col = df_m, annotation_colors = ann_colors2, fontsize = 1.5)
```

```{r, top-150-genes-deseq-all, out.height="570px", out.width ="800px"}
topgenes_byensemblid_m <- head(rownames(res_aff_vs_unaff_df_m), 150)
topgenes_aff_vs_unaff_05_m <- assay(vsd_limma)[topgenes_byensemblid_m, ]
topgenes_aff_vs_unaff_05_m <- topgenes_aff_vs_unaff_05_m - rowMeans(topgenes_aff_vs_unaff_05_m)

ensembl_to_gene_m <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)

# Get the current row names of the matrix 'mat'
current_ensembl_ids_m <- rownames(topgenes_aff_vs_unaff_05_m)

# Find the corresponding gene names for the Ensembl IDs
new_row_names_m <- ensembl_to_gene_m[current_ensembl_ids_m]

# Set the new row names for the matrix 'mat'
rownames(topgenes_aff_vs_unaff_05_m) <- new_row_names_m

#topgenes_aff_vs_unaff_05_m <- topgenes_aff_vs_unaff_05_m[order(row.names(topgenes_aff_vs_unaff_05_m)), ]

df_m <- as.data.frame(colData(vsd_limma)[, c("Affected", "Category")])
pheatmap(topgenes_aff_vs_unaff_05_m, annotation_col = df_m, annotation_colors = ann_colors2, fontsize = 3.75)
```



```{r, all-genes-female-only}
gb_df <- genes_biomart[, c(1, ncol(genes_biomart))]
res_aff_vs_unaff_df_genename <- res_aff_vs_unaff_df
res_aff_vs_unaff_df_genename$Ensembl_ID <- row.names(res_aff_vs_unaff_df)
res_aff_vs_unaff_df_genename <- merge(x = res_aff_vs_unaff_df_genename, y = gene_info, by.x = "Ensembl_ID", by.y = "Ensembl_ID", all.x = TRUE)
res_aff_vs_unaff_df_genename <- res_aff_vs_unaff_df_genename[, c(dim(res_aff_vs_unaff_df_genename)[2], 1:dim(res_aff_vs_unaff_df_genename)[2] - 1)]
res_aff_vs_unaff_df_genename <- res_aff_vs_unaff_df_genename[order(res_aff_vs_unaff_df_genename[, "padj"]), ]
write.csv(res_aff_vs_unaff_df_genename, file = "output/res_aff_vs_unaff_genename.csv")
```

```{r, all-genes-list}
gb_df <- genes_biomart[, c(1, ncol(genes_biomart))]
res_aff_vs_unaff_df_m_genename <- res_aff_vs_unaff_df_m
res_aff_vs_unaff_df_m_genename$Ensembl_ID <- row.names(res_aff_vs_unaff_df_m)
res_aff_vs_unaff_df_m_genename <- merge(x = res_aff_vs_unaff_df_m_genename, y = gene_info, by.x = "Ensembl_ID", by.y = "Ensembl_ID", all.x = TRUE)
res_aff_vs_unaff_df_m_genename <- res_aff_vs_unaff_df_m_genename[, c(dim(res_aff_vs_unaff_df_m_genename)[2], 1:dim(res_aff_vs_unaff_df_m_genename)[2] - 1)]
res_aff_vs_unaff_df_m_genename <- res_aff_vs_unaff_df_m_genename[order(res_aff_vs_unaff_df_m_genename[, "padj"]), ]
write.csv(res_aff_vs_unaff_df_m_genename, file = "output/res_aff_vs_unaff_df_m_genename.csv")
```

```{r, top50-with-genename-padj}
res_aff_vs_unaff_df_genename_05 <- subset(res_aff_vs_unaff_df_m_genename, padj < 0.05)
res_aff_vs_unaff_df_genename_05 <- res_aff_vs_unaff_df_genename_05[order(res_aff_vs_unaff_df_genename_05$padj), ]
write.csv(res_aff_vs_unaff_df_genename_05, file = "output/res_aff_vs_unaff_df_genename_05.csv")
write.csv(res_aff_vs_unaff_df_05_m, file = "output/res_aff_vs_unaff_df_m_genename_05.csv")

res_aff_vs_unaff_df_genename_1 <- subset(res_aff_vs_unaff_df_m_genename, padj < 0.1)
res_aff_vs_unaff_df_genename_1 <- res_aff_vs_unaff_df_genename_1[order(res_aff_vs_unaff_df_genename_1$padj), ]
write.csv(res_aff_vs_unaff_df_genename_1, file = "output/res_aff_vs_unaff_df_genename_padj1.csv")
```

Below is a table of information about the top genes.

```{r, padj-gene-info}
library(mygene)

genes <- res_aff_vs_unaff_df_genename_05$gene_name
my_gene_data <- queryMany(genes, scopes = "symbol", fields = c("symbol", "name", "summary", species = "human"))

#paged_table(my_gene_data, options = list(rows.print = 15))
```

```{r, maplot-all-samples}
filtered_gene_names <- res_aff_vs_unaff_df_m_genename$gene_name[!grepl("^ENS", res_aff_vs_unaff_df_m_genename$gene_name)]
# Select specific genes to show
# set top = 0, then specify genes using label.select argument
maplot <- ggmaplot(res_aff_vs_unaff_df_m,
  main = "Affected vs Unaffected MA Plot",
  fdr = .1, fc = 1, size = 0.4, # Same used for others.
  genenames = as.vector(res_aff_vs_unaff_df_m_genename$gene_name),
  ggtheme = ggplot2::theme_minimal(),
  legend = "top", top = 20,
  label.select = c("KCNQ5"),
  font.label = c("bold", 5), label.rectangle = TRUE,
  font.legend = "bold", font.main = "bold"
)

maplot

significant_data <- subset(maplot$data, grepl("Up|Down", sig))

paged_table(as.data.frame(significant_data), options = list(rows.print = 20))
# Save significant genes
write.csv(significant_data, file = "output/res_aff_vs_unaff_significant_all_samples.csv", row.names = FALSE)
```

## Expression of Candidate Genes

Below is a table of expression of the genes identified during our WGS analysis. 

8 of the genes were not included using DESeq2's count filtering method (these genes had no counts):

"DPEP1", "RERGL", "TDO2", "CCDC178", "ADRA1D", "AVPR1B", "LRCOL1", "KCNJ18"

```{r, genes-of-interest-table}
# Subset gene_info using genes of interest
subset_gene_info <- gene_info[gene_info$gene_name %in% genes_of_interest, ]

filtered_by_interest <- filter(res_aff_vs_unaff_df_m_genename, Ensembl_ID %in% subset_gene_info$Ensembl_ID)

# Filtering the dataframe by row names
filtered_counts <- counts[row.names(counts) %in% subset_gene_info$Ensembl_ID, ]

# Match and update row names
matching_indices <- match(rownames(filtered_counts), subset_gene_info$Ensembl_ID)

# Update row names based on matching_column values from metadata
rownames(filtered_counts) <- subset_gene_info$gene_name[matching_indices]

missing_genes <- setdiff(subset_gene_info$Ensembl_ID, filtered_by_interest$Ensembl_ID)

corresponding_gene_names <- subset_gene_info$gene_name[subset_gene_info$Ensembl_ID %in% missing_genes]

missing_gene_counts <- counts[row.names(counts) %in% missing_genes, ]

paged_table(filtered_by_interest, options = list(rows.print = 15))

paged_table(filtered_counts, options = list(rows.print = 15))
```


Below is a heatmap highlighting the expression of our genes of interest across batch, disease group, and affected status.

```{r, heatmap-genes-interest-female, out.width = "1200px"}
mat2 <- assay(vsd_limma_female)[filtered_by_interest$Ensembl_ID, ]
rownames(mat2) <- gene_info$gene_name[match(filtered_by_interest$Ensembl_ID, gene_info$Ensembl_ID)]
df <- as.data.frame(colData(vsd_limma_female)[, c("Affected", "Category")])
pheatmap(mat2, annotation_col = df, annotation_colors = ann_colors2, fontsize = 4)
```

```{r, heatmap-genes-interest-all, out.width = "1200px"}
mat2 <- assay(vsd_limma)[filtered_by_interest$Ensembl_ID, ]
rownames(mat2) <- gene_info$gene_name[match(filtered_by_interest$Ensembl_ID, gene_info$Ensembl_ID)]
df_m <- as.data.frame(colData(vsd)[, c("Affected", "Category")])
pheatmap(mat2, annotation_col = df_m, annotation_colors = ann_colors2, fontsize = 4)
```

## Enrichment analysis

```{r, gostplot}
#res <- gost(query = significant_data$name, organism = "hsapiens", significant = FALSE) # should significant be true or false?

#gostplot(res, capped = FALSE, interactive = TRUE)
```

```{r, enrichgo}
# #res <- gost(query = significant_data$name, organism = "hsapiens", significant = FALSE) # should significant be true or false?
# 
# #gostplot(res, capped = FALSE, interactive = TRUE)
# # Get entrez id
# 
# # Your existing code for obtaining geneList with Ensembl IDs
# rownames(res_aff_vs_unaff_df) <- gsub("\\..*", "", rownames(res_aff_vs_unaff_df))
# geneList <- res_aff_vs_unaff_df$log2FoldChange
# names(geneList) <- rownames(res_aff_vs_unaff_df)
# 
# # Initialize BioMart
# ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
# 
# # Convert all Ensembl IDs in geneList to Entrez IDs
# attributes <- c('ensembl_gene_id', 'entrezgene_id')
# filters <- 'ensembl_gene_id'
# results <- getBM(attributes = attributes, filters = filters, values = names(geneList), mart = ensembl)
# 
# # Remove rows with NA or empty Entrez IDs
# results <- results[!is.na(results$entrezgene_id) & results$entrezgene_id != "",]
# 
# # Create a new geneList with Entrez IDs
# geneList_entrez <- geneList[results$ensembl_gene_id]
# names(geneList_entrez) <- results$entrezgene_id
# 
# # Filter genes with abs(log2FoldChange) > 2
# gene_entrez <- names(geneList_entrez)[abs(geneList_entrez) > 2]
# # Run enrichGO with Entrez IDs
# ego_cc <- enrichGO(gene       = gene_entrez,
#                 universe      = names(geneList_entrez),
#                 OrgDb         = org.Hs.eg.db,
#                 ont           = "CC",
#                 pAdjustMethod = "BH",
#                 pvalueCutoff  = 0.01,
#                 qvalueCutoff  = 0.05,
#                 readable      = TRUE)
# 
# # Plot results
# barplot(ego_cc, showCategory=10) + ggthemes::theme_clean()
# 
# 
# ego_bp <- enrichGO(gene       = gene_entrez,
#                 universe      = names(geneList_entrez),
#                 OrgDb         = org.Hs.eg.db,
#                 ont           = "BP",
#                 pAdjustMethod = "BH",
#                 pvalueCutoff  = 0.01,
#                 qvalueCutoff  = 0.05,
#                 readable      = TRUE)
# 
# # Plot results
# barplot(ego_bp, showCategory=10) + ggthemes::theme_clean()
# 
# 
# ego_mf <- enrichGO(gene       = gene_entrez,
#                 universe      = names(geneList_entrez),
#                 OrgDb         = org.Hs.eg.db,
#                 ont           = "MF",
#                 pAdjustMethod = "BH",
#                 pvalueCutoff  = 0.01,
#                 qvalueCutoff  = 0.05,
#                 readable      = TRUE)
# 
# # Plot results
# barplot(ego_mf, showCategory=10) + ggthemes::theme_clean()
# ```
# 
# ```{r, enrichplot}
# top_genes_df <- res_aff_vs_unaff_df[order(-abs(res_aff_vs_unaff_df$log2FoldChange)), ]
# top_20_genes <- rownames(top_genes_df)[1:20]
# 
# # Enriched via DisGeNet
# edo <- enrichDGN(gene_entrez)
# barplot(edo, showCategory=20) 
```


```{r, upsetplots}
# upsetplot(ego_mf)
```

```{r, generate-plot-counts-genes-interest}
# For loop for plot counts
for (ensembl_id in filtered_by_interest$Ensembl_ID) {
    d <- plotCounts(dds, gene=ensembl_id, intgroup="Affected", returnData=TRUE)
    gene_name <- filtered_by_interest$gene_name[filtered_by_interest$Ensembl_ID == ensembl_id]
    ggplot_box <- ggboxplot(d, x="Affected", y="count", add = "jitter", color = "Affected", palette = c("navy", "red"), title = gene_name) + geom_text_repel(aes(label = rownames(d)))
    print(ggplot_box) # Ensure each plot is printed during the loop
    ggsave(filename = paste0(gene_name, "-plot-counts.png"), 
           path = "output/batch-correction-limma/plot-counts",
           plot = ggplot_box, dpi = 450)
}
```

### Save data

```{r, save-data}
save.image(file = "output/condition-analysis.RData")
```

