---
title: "Differential Gene Expression (DGE) Analysis"
output:
  workflowr::wflow_html:
    toc: true
    toc_depth: 3
    toc_float: true
    code_folding: hide
editor_options:
  chunk_output_type: console
---

```{r, setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# DGE Analysis Setup {.tabset}

Ensure you have all necessary libraries installed and load the helper code.

At a later date, `renv` will be integrated to ensure reproducibility of this analysis.

Use the below code to install these packages:


```
# Install packages from CRAN
install.packages(c("tidyverse", "RColorBrewer", "pheatmap", "gprofiler2", "plotly"))

# Install packages from Bioconductor
install.packages("BiocManager")
BiocManager::install(c("DESeq2", "genefilter", "limma", "biomaRt"))
```

```{r, load libraries, warning = FALSE, message = FALSE}
library(tidyverse) # Available via CRAN
library(DESeq2) # Available via Bioconductor
library(RColorBrewer) # Available via CRAN
library(pheatmap) # Available via CRAN
library(genefilter) # Available via Bioconductor
library(limma) # Available via Bioconductor
library(gprofiler2) # Available via CRAN
library(biomaRt) # Available via Bioconductor
library(plotly) # Available via CRAN
library(ggpubr)
library(rmarkdown)
```

```{r, include=FALSE}
source("code/helpers.R", local = knitr::knit_global())
# or sys.source("your-script.R", envir = knitr::knit_global())
```

## Data Import

We will be importing counts data from the star-salmon pipeline and our metadata 
for the project which is hosted on Box. This also ensures data is properly ordered by sample id.

```{r, import data}
counts <- read_tsv("data/star-salmon/salmon.merged.gene_counts_length_scaled.tsv")

# Import variants of interest
vars_of_interest <- read_csv("data/RNAseq Variants of Interest List_V2.csv")
genes_of_interest <- unique(vars_of_interest$Gene)
genes_of_interest <- genes_of_interest[!is.na(genes_of_interest)]

# Use first column (gene_id) for row names
counts <- data.frame(counts, row.names = 1)
counts$Ensembl_ID <- row.names(counts)
drop <- c("Ensembl_ID", "gene_name")
gene_info <- counts[, drop]
counts <- counts[, !(names(counts) %in% drop)] # remove both columns

# Import metadata
sample_metadata <- read_csv("data/MECFS_RNAseq_metadata_2023_08_18.csv")
row.names(sample_metadata) <- sample_metadata$RNA_Samples_id

# Check that data is ordered properly
sample_metadata <- check_order(sample_metadata = sample_metadata, counts = counts)

genes_biomart <- retrieve_gene_info(values = gene_info$Ensembl_ID, filters = "ensembl_gene_id_version")
```

## DESeq2 Analysis

```{r, start analysis}
sample_metadata$Family <- factor(sample_metadata$Family)
sample_metadata$Affected <- factor(sample_metadata$Affected)
sample_metadata$Batch <- factor(sample_metadata$Batch)
sample_metadata$Sex <- factor(sample_metadata$Sex)

# Account for Family later but batch is accounted for
# Account for another factor seems to be an issue.
dds <- DESeqDataSetFromMatrix(countData = round(counts), colData = sample_metadata, design = ~ Batch + Affected)

# Pre-filtering: Keep only rows that have at least 10 reads total
keep <- rowSums(counts(dds)) >= 10
dds <- dds[keep, ]

# Remove male samples
male_samples <- c("LW001994", "LW001984", "LW001985")
# Create a logical vector to index the columns you want to keep
female_samples <- !(colnames(dds) %in% male_samples)
dds_female <- dds[, female_samples]

# Run DESeq function
dds <- DESeq(dds)
dds_female <- DESeq(dds_female)

# Normalize gene counts for differences in seq. depth/global differences
counts_norm <- counts(dds, normalized = TRUE)
counts_norm_female <- counts(dds_female, normalized = TRUE)
```

### Data transformation and visualization

Perform count data transformation by variance stabilizing transformation (vst) on normalized counts.

```{r, vsd}
vsd <- vst(dds, blind = FALSE)
vsd_female <- vst(dds_female, blind = FALSE)
```

### Batch correction with limma

```{r, limma}
counts_vst <- assay(vsd)
write.csv(counts_vst, file = "output/counts_vst.csv")
mm <- model.matrix(~ Batch + Affected, colData(vsd))

counts_vst_limma <- limma::removeBatchEffect(counts_vst, batch = vsd$Batch, design = mm)

write.csv(counts_vst_limma, file = "output/counts_vst_limma.csv")

vsd_limma <- vsd
assay(vsd_limma) <- counts_vst_limma

# For just female samples
counts_vst_female <- assay(vsd_female)
write.csv(counts_vst_female, file = "output/counts_vst_female.csv")
mm <- model.matrix(~ Batch + Affected, colData(vsd_female))

counts_vst_limma_female <- limma::removeBatchEffect(counts_vst_female, batch = vsd_female$Batch, design = mm)

write.csv(counts_vst_limma_female, file = "output/counts_vst_limma_female.csv")

vsd_limma_female <- vsd_female
assay(vsd_limma_female) <- counts_vst_limma_female
```

### Sample distances heatmap

```{r, sample-dist-heatmap}
sample_dists <- dist(t(assay(vsd_limma_female)))
sample_dist_matrix <- as.matrix(sample_dists)
rownames(sample_dist_matrix) <- paste(vsd_limma_female$Batch, vsd_limma_female$Affected, sep = " | ")
colnames(sample_dist_matrix) <- paste(vsd_limma_female$RNA_Samples_id, vsd_limma_female$Affected, sep = " | ")
colors <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)

pheatmap(sample_dist_matrix, clustering_distance_rows = sample_dists, clustering_distance_cols = sample_dists, col = colors)
```


### Principal Components Analysis

Our below PCA shows that there does not seem to be a batch-related effect occurring after using limma. However, we can see that our 3 male samples are grouping. Given this knowledge, removing them from downstream analyses is the best option.

```{r, principal-components-analysis-all}
pca_data <- plotPCA(vsd_limma, intgroup = c("Batch", "Sex", "Affected"), returnData = TRUE)
percent_var <- round(100 * attr(pca_data, "percentVar"))

ggplot(pca_data, aes(PC1, PC2)) +
  geom_point(aes(colour = Affected, fill = Sex, shape = Batch), size = 4) +
    scale_shape_manual(values = c(21, 22, 23) )+
  scale_fill_manual(values = c("white","gray"))+
  scale_color_manual(values=c("blue","red"))+
  geom_text(aes(label = name),
    data = subset(pca_data, PC2 < -18 | PC1 < -30 ),
    vjust = -1, hjust = 0.5, size = 2.5
  ) +
  xlab(paste0("PC1: ", percent_var[1], "% variance")) +
  ylab(paste0("PC2: ", percent_var[2], "% variance")) +
  coord_fixed()
```
Below is PCA with only female samples.

```{r, principal-components-analysis-all}
pca_data_female <- plotPCA(vsd_limma_female, intgroup = c("Batch", "Affected"), returnData = TRUE)
percent_var_female <- round(100 * attr(pca_data_female, "percentVar"))

ggplot(pca_data_female, aes(PC1, PC2)) +
  geom_point(aes(shape = Batch, colour = Affected), size = 4) +
   scale_color_manual(values=c("blue","red")) +
  geom_text(aes(label = name),
    data = subset(pca_data_female, PC2 < -15 | PC1 > 25 | PC1 < -40 ),
    vjust = -1, hjust = 0.5, size = 2.5
  ) +
  xlab(paste0("PC1: ", percent_var_female[1], "% variance")) +
  ylab(paste0("PC2: ", percent_var_female[2], "% variance")) +
  coord_fixed()
```

### Heatmap of all genes, top 50  & top 100 genes


This is a heatmap for all genes across samples.

```{r, all-heatmap, out.height="570px", out.width ="800px"}
# Specify annotation colors by columns
# Specify colors
ann_colors = list(
    Batch = c("white", "firebrick"),
    Affected = c(Yes = "red", No = "navy"),
    Disease.Group = c(Path1 = "#7570B3", Path2 = "#E7298A", Path3 = "#66A61E",
                      )
)

all_genes <- order(-rowVars(assay(vsd_limma_female)))
mat <- assay(vsd_limma)[all_genes, ]
mat <- mat - rowMeans(mat)
df <- as.data.frame(colData(vsd)[, c("Batch", "Affected", "Disease.Group")])
pheatmap(mat, annotation_col = df, annotation_colors = ann_colors, fontsize = 5)
```


This is a heatmap for 50 genes with the highest variance across samples.

```{r, top50-heatmap, out.height="570px", out.width ="800px"}
top_var_genes <- head(order(-rowVars(assay(vsd_limma_female))), 50)
mat <- assay(vsd_limma_female)[top_var_genes, ]
mat <- mat - rowMeans(mat)
df <- as.data.frame(colData(vsd_limma_female)[, c("Batch", "Affected", "Disease.Group")])
pheatmap(mat, annotation_col = df, fontsize = 5)
```

This is a heatmap of the top 100 genes with the highest variance across samples. 
```{r, top100-heatmap, out.width = "1200px"}
top_var_genes_100 <- head(order(-rowVars(assay(vsd_limma_female))), 100)
mat_100 <- assay(vsd_limma_female)[top_var_genes_100, ]
mat_100 <- mat_100 - rowMeans(mat_100)
df_100 <- as.data.frame(colData(vsd_limma_female)[, c("Batch", "Affected", "Disease.Group")])
pheatmap(mat_100, annotation_col = df_100, fontsize = 6)
```

### Comparison/Contrast of Affected_Yes_vs_No 

```{r}
res_aff_vs_unaff <- results(dds_female, contrast = c("Affected", "Yes", "No"))
res_aff_vs_unaff_df <- process_and_save_results(res_aff_vs_unaff, 
                                                "output/res_aff_vs_unaff.csv")
res_aff_vs_unaff_df_05 <- subset(res_aff_vs_unaff_df, padj < 0.05)

summary(res_aff_vs_unaff)
```

```{r, top 50 genes, out.height="570px", out.width ="800px"}
topgenes_byensemblid <- head(rownames(res_aff_vs_unaff_df), 50)
topgenes_aff_vs_unaff_05 <- assay(vsd_limma)[topgenes_byensemblid, ]
topgenes_aff_vs_unaff_05 <- topgenes_aff_vs_unaff_05 - rowMeans(topgenes_aff_vs_unaff_05)

# Convert ensemblids
ensemblids <- topgenes_byensemblid
ensemblids
rownames(topgenes_aff_vs_unaff_05) <- gene_info$gene_name[match(ensemblids, gene_info$Ensembl_ID)]

topgenes_aff_vs_unaff_05 <- topgenes_aff_vs_unaff_05[order(row.names(topgenes_aff_vs_unaff_05)), ]

df <- as.data.frame(colData(vsd_limma)[, c("Batch", "Affected", "Disease.Group")])
pheatmap(topgenes_aff_vs_unaff_05, annotation_col = df, fontsize = 5)
```


```{r, all-genes}
gb_df <- genes_biomart[, c(1, ncol(genes_biomart))]
res_aff_vs_unaff_df_genename <- res_aff_vs_unaff_df
res_aff_vs_unaff_df_genename$Ensembl_ID <- row.names(res_aff_vs_unaff_df)
res_aff_vs_unaff_df_genename <- merge(x = res_aff_vs_unaff_df_genename, y = gene_info, by.x = "Ensembl_ID", by.y = "Ensembl_ID", all.x = TRUE)
res_aff_vs_unaff_df_genename <- res_aff_vs_unaff_df_genename[, c(dim(res_aff_vs_unaff_df_genename)[2], 1:dim(res_aff_vs_unaff_df_genename)[2] - 1)]
res_aff_vs_unaff_df_genename <- res_aff_vs_unaff_df_genename[order(res_aff_vs_unaff_df_genename[, "padj"]), ]
write.csv(res_aff_vs_unaff_df_genename, file = "output/res_aff_vs_unaff_genename.csv")
```

```{r, top50-with-genename-padj}
res_aff_vs_unaff_df_genename_05 <- subset(res_aff_vs_unaff_df_genename, padj < 0.05)
res_aff_vs_unaff_df_genename_05 <- res_aff_vs_unaff_df_genename_05[order(res_aff_vs_unaff_df_genename_05$padj), ]
write.csv(res_aff_vs_unaff_df_genename_05, file = "output/res_aff_vs_unaff_df_genename_05.csv")
```

Below is a table of information about the top genes.

```{r, padj-gene-info}
library(mygene)

genes <- res_aff_vs_unaff_df_genename_05$gene_name
data <- queryMany(genes, scopes = "symbol", fields = c("entrezgene", "symbol", "name", "summary", species = "human"))

paged_table(as.data.frame(data), options = list(rows.print = 15))
```

```{r, maplot}
# Select specific genes to show
# set top = 0, then specify genes using label.select argument
maplot <- ggmaplot(res_aff_vs_unaff_df,
  main = "Affected vs Unaffected MA Plot",
  fdr = .05, fc = 2, size = 0.4,
  genenames = as.vector(res_aff_vs_unaff_df_genename$gene_name),
  ggtheme = ggplot2::theme_minimal(),
  legend = "top", top = 30, font.label = c("bold", 5), label.rectangle = TRUE,
  font.legend = "bold", font.main = "bold"
)

maplot

significant_data <- subset(maplot$data, grepl("Up|Down", sig))
significant_data$sig <- ifelse(grepl("Up", significant_data$sig), "Up",
  ifelse(grepl("Down", significant_data$sig), "Down", significant_data$sig)
)

paged_table(significant_data, options = list(rows.print = 20))
```

## Expression of Candidate Genes

Below is a table of expression of the genes identified during our WGS analysis. 

8 of the genes were not included using DESeq2's count filtering method (these genes had no counts):

"DPEP1", "RERGL", "TDO2", "CCDC178", "ADRA1D", "AVPR1B", "LRCOL1", "KCNJ18"

```{r, genes-of-interest-table}
# Subset gene_info using genes of interest
subset_gene_info <- gene_info[gene_info$gene_name %in% genes_of_interest, ]

filtered_by_interest <- filter(res_aff_vs_unaff_df_genename, Ensembl_ID %in% subset_gene_info$Ensembl_ID)

# Filtering the dataframe by row names
filtered_counts <- counts[row.names(counts) %in% subset_gene_info$Ensembl_ID, ]

# Match and update row names
matching_indices <- match(rownames(filtered_counts), subset_gene_info$Ensembl_ID)

# Update row names based on matching_column values from metadata
rownames(filtered_counts) <- subset_gene_info$gene_name[matching_indices]

missing_genes <- setdiff(subset_gene_info$Ensembl_ID, filtered_by_interest$Ensembl_ID)

corresponding_gene_names <- subset_gene_info$gene_name[subset_gene_info$Ensembl_ID %in% missing_genes]

missing_gene_counts <- counts[row.names(counts) %in% missing_genes, ]

paged_table(filtered_by_interest, options = list(rows.print = 15))

paged_table(filtered_counts, options = list(rows.print = 15))
```


Below is a heatmap highlighting the expression of our genes of interest across batch, disease group, and affected status.

```{r, heatmap-genes-interest, out.width = "1200px"}
mat2 <- assay(vsd_limma)[filtered_by_interest$Ensembl_ID, ]
rownames(mat2) <- gene_info$gene_name[match(filtered_by_interest$Ensembl_ID, gene_info$Ensembl_ID)]
df <- as.data.frame(colData(vsd)[, c("Batch", "Affected", "Disease.Group")])
pheatmap(mat2, annotation_col = df, fontsize = 5)
```

## Enrichment analysis

```{r, gostplot}
res <- gost(query = significant_data$name, organism = "hsapiens", significant = FALSE)

gostplot(res, capped = FALSE, interactive = TRUE)
```


### Save data

```{r, save-data}
save.image(file = "output/condition-analysis.RData")
```
