---
title: "SPTA1 vs Unaffected Differential Gene Expression (DGE) Analysis"
author: "Shaurita D. Hutchins"
date: "`r format(Sys.Date(), 'Last updated on %Y-%m-%d')`"
output:
  workflowr::wflow_html:
    toc: true
    toc_depth: 3
    toc_float: true
    code_folding: hide
editor_options:
  chunk_output_type: console
---

```{r, setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# DGE Analysis Setup

Ensure you have all necessary libraries installed and load the helper code.


```{r, load libraries, warning = FALSE, message = FALSE}
library(tidyverse) # Available via CRAN
library(DESeq2) # Available via Bioconductor
library(RColorBrewer) # Available via CRAN
library(pheatmap) # Available via CRAN
library(genefilter) # Available via Bioconductor
library(limma) # Available via Bioconductor
library(gprofiler2) # Available via CRAN
library(biomaRt) # Available via Bioconductor
library(plotly) # Available via CRAN
library(ggpubr) # Available via CRAN
library(rmarkdown) # Available via CRAN
library(clusterProfiler) # Available via Bioconductor
library(org.Hs.eg.db) # Available via Bioconductor
library(ggrepel) # Available via CRAN
library(ReactomePA) # Available via Bioconductor
library(mygene) # Available via Bioconductor
library(DOSE) # Available via Bioconductor
library(enrichR) # Available via Bioconductor
library(STRINGdb) # Available via Bioconductor
library(EnhancedVolcano)
library(ComplexHeatmap)
```

```{r, include=FALSE}
source("code/helpers.R", local = knitr::knit_global())
# or sys.source("your-script.R", envir = knitr::knit_global())
```

## Data Import

We will be importing counts data from the star-salmon pipeline and our metadata 
for the project which is hosted on Box. This also ensures data is properly ordered by sample id.

```{r, import data}
counts <- read_tsv("data/star-salmon/salmon.merged.gene_counts_length_scaled.tsv")

# Import variants of interest
genes_of_interest <- read_csv("data/Prioritized_Genes_From_WGS_2024_11_19.csv")
genes_of_interest <- unique(genes_of_interest$Genes)
genes_of_interest <- genes_of_interest[!is.na(genes_of_interest)]
# Add a gene manually to the list
genes_of_interest <- unique(c(genes_of_interest, "CHI3L1"))

# Use first column (gene_id) for row names
counts <- data.frame(counts, row.names = 1)
counts$Ensembl_ID <- row.names(counts)
drop <- c("Ensembl_ID", "gene_name")
gene_info <- counts[, drop]
counts <- counts[, !(names(counts) %in% drop)] # remove both columns

# Import metadata
sample_metadata <- read_csv("data/Metadata_2024_11_20.csv")
row.names(sample_metadata) <- sample_metadata$ID

# Assuming counts is your counts dataframe and sample_metadata is your metadata dataframe
# Rename columns in counts to match metadata IDs
counts <- rename_counts_columns(counts, sample_metadata, "ID", "RNA_Samples_id")

# What gene (based on variants samples have) is this analysis based on
genetic_variant <- "SPTA1"
genetic_variant_lower <- tolower(genetic_variant) # Convert to lowercase
outpath_var <- paste0(genetic_variant_lower, "-analysis")

# Filter metadata for Variant column values of "Unaffected" and "SPTA1"
sample_metadata <- sample_metadata %>%
  filter(Variant %in% c("Unaffected", genetic_variant))

# Ensure counts dataframe has only the filtered samples
filtered_sample_ids <- sample_metadata$ID
counts <- counts[, colnames(counts) %in% filtered_sample_ids, drop = FALSE]

# Ensure columns are in the same order as the metadata IDs
counts <- counts[, match(filtered_sample_ids, colnames(counts))]

# Check that data is ordered properly
sample_metadata <- check_order(sample_metadata = sample_metadata, counts = counts)

genes_biomart <- retrieve_gene_info(values = gene_info$Ensembl_ID, filters = "ensembl_gene_id_version")
```

## DESeq2 Analysis

```{r, start analysis}
sample_metadata$Family <- factor(sample_metadata$Family)
sample_metadata$Affected <- factor(sample_metadata$Affected)
sample_metadata$Batch <- factor(sample_metadata$Batch)
sample_metadata$Sex <- factor(sample_metadata$Sex)
sample_metadata$Ancestry <- factor(sample_metadata$Ancestry)
sample_metadata$SubCategory <- factor(sample_metadata$SubCategory)
sample_metadata$Category <- factor(sample_metadata$Category)
sample_metadata$OverallCategory <- factor(sample_metadata$`Overall category assigned`)
sample_metadata$Variant <- factor(sample_metadata$Variant)

# Account for Family later but batch is accounted for
# Accounting for another factor seems to be an issue.
dds <- DESeqDataSetFromMatrix(
  countData = round(counts), colData = sample_metadata,
  design = ~ Batch + Variant
)

# Pre-filtering: Keep only rows that have at least 10 reads total
keep <- rowSums(counts(dds)) >= 50
dds <- dds[keep, ]

# Run DESeq function
dds <- DESeq(dds)

# Normalize gene counts for differences in seq. depth/global differences
counts_norm <- counts(dds, normalized = TRUE)
```

### Data transformation and visualization

Perform count data transformation by variance stabilizing transformation (vst) on normalized counts.

```{r, vsd}
vsd <- vst(dds, blind = FALSE)
```

### Batch correction with limma

```{r, limma}
counts_vst <- assay(vsd)
write.csv(counts_vst, file.path("output", outpath_var, "counts_vst.csv"))
mm <- model.matrix(~ Batch + Variant, colData(vsd))

counts_vst_limma <- limma::removeBatchEffect(counts_vst,
  batch = vsd$Batch,
  design = mm
)

write.csv(counts_vst_limma, file = file.path("output", outpath_var, "counts_vst_limma.csv"))

vsd_limma <- vsd
assay(vsd_limma) <- counts_vst_limma
```

### Sample distances heatmap

```{r, sample-dist-heatmap}
sample_dists_all <- dist(t(assay(vsd_limma)))
sample_dist_matrix_all <- as.matrix(sample_dists_all)
rownames(sample_dist_matrix_all) <- paste(vsd_limma$Batch, vsd_limma$Affected,
  sep = " | "
)
colnames(sample_dist_matrix_all) <- paste(vsd_limma$ID, vsd_limma$Affected,
  sep = " | "
)
colors <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)

pheatmap(sample_dist_matrix_all,
  clustering_distance_rows = sample_dists_all,
  clustering_distance_cols = sample_dists_all, col = colors
)
```

### Principal Components Analysis

Our below PCA shows that there does not seem to be a batch-related effect 
occurring after using limma. However, we can see that our 3 male samples are 
grouping. Given this knowledge, removing them from downstream analyses is the best option.

```{r, principal-components-analysis-all}
pca_data_all <- plotPCA(vsd_limma,
  intgroup = c("Batch", "Variant"),
  returnData = TRUE
)
percent_var_all <- round(100 * attr(pca_data_all, "percentVar"))

ggplot(pca_data_all, aes(PC1, PC2)) +
  geom_point(aes(colour = Variant, shape = Batch), size = 4) +
  xlab(paste0("PC1: ", percent_var_all[1], "% variance")) +
  ylab(paste0("PC2: ", percent_var_all[2], "% variance")) +
  coord_fixed()
```


```{r, principal-components-analysis-category}
pca_data_all <- plotPCA(vsd_limma,
  intgroup = c("OverallCategory"),
  returnData = TRUE
)
percent_var_all <- round(100 * attr(pca_data_all, "percentVar"))

ggplot(pca_data_all, aes(PC1, PC2)) +
  geom_point(aes(colour = OverallCategory), size = 5) +
  scale_colour_manual(
    values = c(
      "#B3DE69", "#FFFFB3", "#BEBADA", "#FB8072", "#000000"
    ),
    name = "OverallCategory"
  ) +
  # geom_text(aes(label = name), vjust = -.75, hjust = -.5, size = 3) +
  # geom_text_repel(aes(label = name), size = 5, vjust = -2, hjust = -0.65) +
  geom_text_repel(aes(label = name), size = 3) +
  xlab(paste0("PC1: ", percent_var_all[1], "% variance")) +
  ylab(paste0("PC2: ", percent_var_all[2], "% variance")) +
  ggthemes::theme_clean()
```

```{r, heatmap-colors, out.height="570px", out.width ="800px"}
# Specify annotation colors by columns
# Use RColorBrewer::brewer.pal(n=10, name="Set1")
overall_category_colors <- c(
  "ENE" = "#BFDFBF", # Magenta
  "IMM" = "#EEBFEE", # Light green
  "SOL" = "#FFFF33", # Mustard yellow
  "STR" = "#BFBFFF", # Brown
  "N/A" = "darkgray" # Dark grey
)

variant_colors <- c(
  "CHRFAM7A" = "#80B1D3", # Blue
  "SPTA1" = "#FB8072", # Light red
  "N/A" = "#FDB462", # Orange
  "Unaffected" = "darkgray" # Dark grey
)

ann_colors <- list(
  Batch = c(B1 = "purple", B2 = "firebrick", B3 = "yellow"),
  Affected = c(Affected = "green", Unaffected = "navy"),
  OverallCategory = overall_category_colors,
  Variant = variant_colors
)
```

### Comparison/Contrast of SPTA1 Affected vs Unaffected

```{r}
# Perform differential expression analysis for "Unaffected" vs "SPTA1"
res_aff_vs_unaff <- results(dds, contrast = c("Variant", "Unaffected", "SPTA1"))

# Define output file path for saving results
res_file_name <- file.path("output", outpath_var, "res_spta1_vs_unaff.csv")

# Process results and save them to the output file
res_aff_vs_unaff_df <- process_and_save_results(res_aff_vs_unaff, res_file_name)

# Sort results by adjusted p-value (padj)
res_aff_vs_unaff_df <- arrange(res_aff_vs_unaff_df, padj)

# Filter for significant results (padj < 0.05)
res_aff_vs_unaff_df_05 <- subset(res_aff_vs_unaff_df, padj < 0.05)

# Filter for marginally significant results (padj < 0.1)
res_aff_vs_unaff_df_1 <- subset(res_aff_vs_unaff_df, padj < 0.1)

# Further filter marginally significant results with |log2FoldChange| >= 1
res_aff_vs_unaff_df_padj1_lfc1 <- subset(
  res_aff_vs_unaff_df_1,
  log2FoldChange >= 1 | log2FoldChange <= -1
)

# Further filter significant results with |log2FoldChange| >= 1
res_aff_vs_unaff_df_padj05_lfc1 <- subset(
  res_aff_vs_unaff_df_05,
  log2FoldChange >= 1 | log2FoldChange <= -1
)

# Summarize differential expression results
summary(res_aff_vs_unaff)
```

## Heatmap of Significant Genes


```{r, significant-genes-deseq-padj1-lfc1, out.height="100%", out.width ="100%"}
# Assuming 'res_aff_vs_unaff_df' has a column 'padj' for adjusted p-values or 'pvalue' for p-values
# Ensure the row names of 'res_aff_vs_unaff_df' are Ensembl IDs
# Order the dataframe by padj in ascending order
res_aff_vs_unaff_df <- res_aff_vs_unaff_df[order(res_aff_vs_unaff_df$padj), ]

# Select the top 50 entries
# top_50_res <- head(res_aff_vs_unaff_df, 55)
# topgenes_byensemblid <- rownames(top_50_res)

# Get the most significant genes based on adjusted p-values and log2foldchange of 1
topgenes_byensemblid <- rownames(res_aff_vs_unaff_df_padj1_lfc1)

# Extract the corresponding subset of the data matrix
topgenes_aff_vs_unaff_05 <- assay(vsd_limma)[topgenes_byensemblid, ]

# Normalize by subtracting the row means
topgenes_aff_vs_unaff_05 <- topgenes_aff_vs_unaff_05 - rowMeans(topgenes_aff_vs_unaff_05)

# Map Ensembl IDs to gene names
ensembl_to_gene <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)
current_ensembl_ids <- rownames(topgenes_aff_vs_unaff_05)
new_row_names <- ensembl_to_gene[current_ensembl_ids]
rownames(topgenes_aff_vs_unaff_05) <- new_row_names

# Order the matrix based on significance (most significant to least significant)
topgenes_aff_vs_unaff_05 <- topgenes_aff_vs_unaff_05[order(res_aff_vs_unaff_df$padj[topgenes_byensemblid]), ]

df <- df <- colData(vsd_limma) %>%
  as.data.frame() %>%
  dplyr::select(OverallCategory)

ComplexHeatmap::pheatmap(topgenes_aff_vs_unaff_05, color = colorRampPalette(rev(brewer.pal(
  n = 9, name =
    "RdYlBu"
)))(50), annotation_col = df, annotation_colors = ann_colors, fontsize = 7, angle_col = c("0"), cellheight = 10, cellwidth = 24, border_color = "black", heatmap_legend_param = list(
  title = ""
))
```


```{r, significant-genes-deseq-lfc1, out.height="800px", out.width ="1400px"}
# Assuming 'res_aff_vs_unaff_df' has a column 'padj' for adjusted p-values or 'pvalue' for p-values
# Ensure the row names of 'res_aff_vs_unaff_df' are Ensembl IDs
res_aff_vs_unaff_df <- res_aff_vs_unaff_df[order(res_aff_vs_unaff_df$padj), ]

# Get the most significant genes based on adjusted p-values and log2foldchange of 1
topgenes_byensemblid <- rownames(res_aff_vs_unaff_df_padj05_lfc1)


# Extract the corresponding subset of the data matrix
topgenes_aff_vs_unaff_05 <- assay(vsd_limma)[topgenes_byensemblid, ]

# Normalize by subtracting the row means
topgenes_aff_vs_unaff_05 <- topgenes_aff_vs_unaff_05 - rowMeans(topgenes_aff_vs_unaff_05)

# Map Ensembl IDs to gene names
ensembl_to_gene <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)
current_ensembl_ids <- rownames(topgenes_aff_vs_unaff_05)
new_row_names <- ensembl_to_gene[current_ensembl_ids]
rownames(topgenes_aff_vs_unaff_05) <- new_row_names

# Order the matrix based on significance (most significant to least significant)
topgenes_aff_vs_unaff_05 <- topgenes_aff_vs_unaff_05[order(res_aff_vs_unaff_df$padj[topgenes_byensemblid]), ]

df <- df <- colData(vsd_limma) %>%
  as.data.frame() %>%
  dplyr::select(Variant)

ComplexHeatmap::pheatmap(topgenes_aff_vs_unaff_05, color = colorRampPalette(rev(brewer.pal(
  n = 9, name =
    "RdYlBu"
)))(50), annotation_col = df, annotation_colors = ann_colors, fontsize = 7, angle_col = c("0"), cellheight = 10, cellwidth = 24, border_color = "black", heatmap_legend_param = list(
  title = ""
))
```


```{r, all-genes-list}
# Extract relevant columns from genes_biomart (first and last columns)
gb_df <- genes_biomart[, c(1, ncol(genes_biomart))]

# Copy results dataframe to add gene annotations
res_aff_vs_unaff_df_genename <- res_aff_vs_unaff_df

# Add Ensembl IDs as a new column
res_aff_vs_unaff_df_genename$Ensembl_ID <- row.names(res_aff_vs_unaff_df)

# Merge gene annotation information from gene_info using Ensembl IDs
res_aff_vs_unaff_df_genename <- merge(
  x = res_aff_vs_unaff_df_genename,
  y = gene_info,
  by.x = "Ensembl_ID",
  by.y = "Ensembl_ID",
  all.x = TRUE
)

# Reorder columns to place the newly added gene information first
res_aff_vs_unaff_df_genename <- res_aff_vs_unaff_df_genename[
  ,
  c(
    dim(res_aff_vs_unaff_df_genename)[2],
    1:dim(res_aff_vs_unaff_df_genename)[2] - 1
  )
]

# Sort the dataframe by adjusted p-value (padj)
res_aff_vs_unaff_df_genename <- res_aff_vs_unaff_df_genename[
  order(res_aff_vs_unaff_df_genename[, "padj"]),
]

# Define output file path for the annotated results
res_file_genename <- file.path(
  "output", outpath_var,
  "res_spta1_vs_unaff_df_genename.csv"
)

# Save the annotated results to a CSV file
write.csv(res_aff_vs_unaff_df_genename, file = res_file_genename)
```

## Volcano Plot
```{r, volcano-plot, out.height="1000px", out.width ="1600px"}
# Parameters for the function
res_data <- res_aff_vs_unaff_df_genename
gene_labels <- "gene_name"
x_col <- "log2FoldChange"
y_col <- "padj"
select_genes <- ""
xlab_text <- bquote(~ Log[2] ~ "fold change")
ylab_text <- bquote(~ Log[10] ~ "padj")
xlim_range <- c(-25, 25)
ylim_range <- c(0, 7)
output_volcano_file <- file.path("output", outpath_var, "volcano-plot.png")

# Generate and save the volcano plot
generate_volcano_plot(
  res_data = res_data, gene_labels = gene_labels, x_col = x_col,
  y_col = y_col, select_genes = select_genes, xlab_text = xlab_text,
  ylab_text = ylab_text, p_cutoff = 0.05, fc_cutoff = 1.0,
  xlim_range = xlim_range, ylim_range = ylim_range,
  output_file = output_volcano_file
)
```


```{r, significant-with-genename-padj-lfc}
# Process and save the data
process_and_save_filtered_results(res_aff_vs_unaff_df_genename,
  padj_threshold = 0.05, lfc_threshold = NULL,
  outpath = outpath_var, filename = "res_aff_vs_unaff_df_genename_05.csv"
)

process_and_save_filtered_results(res_aff_vs_unaff_df_genename,
  padj_threshold = 0.05, lfc_threshold = 1,
  outpath = outpath_var, filename = "res_aff_vs_unaff_df_genename_padj05_lfc1.csv"
)

process_and_save_filtered_results(res_aff_vs_unaff_df_genename,
  padj_threshold = 0.1, lfc_threshold = NULL,
  outpath = outpath_var, filename = "res_aff_vs_unaff_df_genename_padj1.csv"
)

process_and_save_filtered_results(res_aff_vs_unaff_df_genename,
  padj_threshold = 0.1, lfc_threshold = 1,
  outpath = outpath_var, filename = "res_aff_vs_unaff_df_genename_padj1_lfc1.csv"
)
```

```{r, maplot-samples}
filtered_gene_names <- res_aff_vs_unaff_df_genename$gene_name[!grepl("^ENS", res_aff_vs_unaff_df_genename$gene_name)]
# Select specific genes to show
# set top = 0, then specify genes using label.select argument
maplot <- generate_ma_plot(
  data = res_aff_vs_unaff_df,
  genenames = as.vector(res_aff_vs_unaff_df_genename$gene_name),
  main_title = "SPTA1 vs Unaffected MA Plot",
  top_genes = 30
)
maplot

significant_data <- maplot$data %>%
  filter(grepl("Up|Down", sig)) %>%
  mutate(direction = ifelse(grepl("Up", sig), "Up", "Down")) %>%
  dplyr::select(-sig) # This removes the 'sig' column

paged_table(as.data.frame(significant_data), options = list(rows.print = 30))
# Save significant genes
output_maplot_siggenes <- file.path(
  "output", outpath_var,
  "res_spta1_vs_unaff_siggenes.csv"
)
write.csv(significant_data, file = output_maplot_siggenes, row.names = FALSE)
```

## Expression of Candidate Genes

Below is a table of expression of the genes identified during our WGS analysis.

```{r, genes-of-interest-table}
# Subset gene_info using genes of interest
subset_gene_info <- gene_info[gene_info$gene_name %in% genes_of_interest, ]

filtered_by_interest <- filter(res_aff_vs_unaff_df_genename, Ensembl_ID %in% subset_gene_info$Ensembl_ID)

# Filtering the dataframe by row names
filtered_counts <- counts[row.names(counts) %in% subset_gene_info$Ensembl_ID, ]

# Match and update row names
matching_indices <- match(rownames(filtered_counts), subset_gene_info$Ensembl_ID)

# Update row names based on matching_column values from metadata
rownames(filtered_counts) <- subset_gene_info$gene_name[matching_indices]

missing_genes <- setdiff(subset_gene_info$Ensembl_ID, filtered_by_interest$Ensembl_ID)

corresponding_gene_names <- subset_gene_info$gene_name[subset_gene_info$Ensembl_ID %in% missing_genes]

missing_gene_counts <- counts[row.names(counts) %in% missing_genes, ]

paged_table(filtered_by_interest, options = list(rows.print = 15))

paged_table(filtered_counts, options = list(rows.print = 15))
```


```{r, stringdb-network-significant}
string_db <- STRINGdb$new(version = "11.5", species = 9606, score_threshold = 100, network_type = "full", input_directory = "")

mapped_degs <- string_db$map(significant_data, "name", removeUnmappedRows = TRUE)
hits <- mapped_degs$STRING_id[1:29]

mapped_degs_dec <- string_db$add_diff_exp_color(mapped_degs, logFcColStr = "lfc")

payload_id <- string_db$post_payload(mapped_degs_dec$STRING_id, colors = mapped_degs_dec$color)
string_db$plot_network(hits, payload_id = payload_id)
```

## Genes of Interest Plot Counts

```{r, generate-plot-counts-genes-interest}
# Create an empty list to store the results for each gene
gene_results_list <- list()

# Create an empty dataframe to store all counts data for plotting
gi_all_counts <- data.frame()

# List of gene names to remove or keep
blood_genes <- c(
  "AHSP", "HEMGN", "SLC4A1", "KEL", "SPTA1", "RHAG",
  "GYPE", "GYPA", "GYPB", "EPB42", "SPTB", "SPTBN5", "CHI3L1"
)

madd_genes <- c(
  "ADM2", "TSHB", "PTH2", "ADORA2B", "GIP", "CGA", "CALCB", "IGHV3-16",
  "ADORA2A", "SYT6", "CYTH2", "VIPR2", "HTR6", "LHCGR", "GIPR", "CGB8",
  "DENND1A", "MADD", "DMXL2", "SMCR8", "TP53TG5", "IGHV3OR16-9"
)

mito_genes <- c(
  "ETFB", "PGM1", "PCK2", "GLYCTK", "ACACB", "MLYCD", "MCCC1",
  "CPT1A", "ELOVL4", "G6PD", "ACADVL", "ACADM", "HADHA", "MCCC2",
  "CPT1C", "CPT1B", "ENO3", "SURF1", "CUBN", "MMACHC", "LMBRD1",
  "MINPP1", "MMAA", "TACO1"
)


combined_genes <- c(blood_genes, madd_genes, mito_genes)

# Remove specific genes
filtered_without_genes <- filtered_by_interest %>%
  filter(!gene_name %in% combined_genes)

# Keep only specific genes
filtered_with_only_genes <- filtered_by_interest %>%
  filter(gene_name %in% blood_genes)

# Keep only specific genes
filtered_with_only_madd_genes <- filtered_by_interest %>%
  filter(gene_name %in% madd_genes)

# Keep only specific genes
filtered_with_only_mito_genes <- filtered_by_interest %>%
  filter(gene_name %in% mito_genes)

# Filtered data without specific genes
write.csv(filtered_without_genes, "output/spta1-analysis/other_genes_of_interest.csv", row.names = FALSE)

# Filtered data with only specific genes (genes_to_filter)
write.csv(filtered_with_only_genes, "output/spta1-analysis/spta1_genes_of_interest.csv", row.names = FALSE)

# Filtered data with only specific MADD genes
write.csv(filtered_with_only_madd_genes, "output/spta1-analysis/madd_genes_of_interest.csv", row.names = FALSE)

# Filtered data with only specific MADD genes
write.csv(filtered_with_only_mito_genes, "output/spta1-analysis/mito_genes_of_interest.csv", row.names = FALSE)


# Process genes of interest
results <- process_genes_of_interest(
  filtered_data = filtered_without_genes,
  dds = dds,
  genes_to_filter = combined_genes,
  output_path = file.path("output", outpath_var, "batch-correction-limma", "plot-counts", "genes-of-interest")
)

# Extract results
faceted_plot <- results$faceted_plot
gene_results_df <- results$gene_results_df

# Save the faceted plot
ggsave(
  filename = "faceted_genes_of_interest_plot_counts.png",
  path = file.path("output", outpath_var, "batch-correction-limma", "plot-counts", "genes-of-interest"),
  plot = faceted_plot, dpi = 2200, create.dir = TRUE
)

# Save the gene results to a CSV
file_name <- file.path("output", outpath_var, "genes_of_interest_plot_counts_signals.csv")
write.csv(gene_results_df, file_name, row.names = FALSE)

# Prepare the heatmap data
mat3 <- assay(vsd_limma)[filtered_without_genes$Ensembl_ID, ]
rownames(mat3) <- gene_info$gene_name[match(filtered_without_genes$Ensembl_ID, gene_info$Ensembl_ID)]
df_sub <- as.data.frame(colData(vsd_limma)[, c("Affected", "OverallCategory")])

# Generate heatmap
create_heatmap(
  mat = assay(vsd_limma)[filtered_without_genes$Ensembl_ID, ],
  gene_info = gene_info,
  vsd_coldata = colData(vsd_limma),
  output_path = file.path("output", outpath_var, "genes-of-interest.png"),
  ann_colors = ann_colors
)
```


## Additional Interesting Genes

```{r, generate-plot-counts-genes-interest-spta1}
# Create an empty list to store the results for each gene
gene_results_list <- list()

# Create an empty dataframe to store all counts data for plotting
gi_all_counts <- data.frame()

# Loop through each gene to calculate and plot counts
for (ensembl_id in filtered_with_only_genes$Ensembl_ID) {
  d <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  dp <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  gene_name <- filtered_with_only_genes$gene_name[filtered_with_only_genes$Ensembl_ID == ensembl_id]

  # Calculate the mean and standard deviation of counts within each condition
  d_stats <- d %>%
    group_by(Affected) %>%
    summarise(
      mean_count = mean(count),
      sd_count = sd(count)
    )

  # Merge statistics back with the data
  d <- merge(d, d_stats, by = "Affected")

  # Create a temporary dataframe to store results for this gene
  temp_gene_df <- data.frame(
    Patient = rownames(d),
    stringsAsFactors = FALSE
  )

  # Calculate Z-scores and determine regulation status
  regulation_status <- sapply(1:nrow(d), function(i) {
    z_score <- (d$count[i] - d$mean_count[i]) / d$sd_count[i]

    # Determine regulation status based on Z-score
    if (z_score > 1) {
      return("Upregulated")
    } else if (z_score < -1) {
      return("Downregulated")
    } else {
      return("Neutral")
    }
  })

  # Add the regulation status to the temporary dataframe
  temp_gene_df[[gene_name]] <- regulation_status

  # Merge the temporary dataframe with the results list
  if (length(gene_results_list) == 0) {
    gene_results_list[[1]] <- temp_gene_df
  } else {
    gene_results_list[[1]] <- merge(gene_results_list[[1]], temp_gene_df, by = "Patient", all = TRUE)
  }

  # Add the gene name to the dp dataframe
  dp$Gene <- gene_name
  dp$Ensembl_ID <- ensembl_id
  dp$SampleID <- rownames(dp)

  # Combine dp with all_counts dataframe
  gi_all_counts <- rbind(gi_all_counts, dp)

  # Generate the boxplot
  gene_plot <- ggboxplot(dp,
    x = "Affected", y = "count", add = "jitter",
    color = "Affected", palette = c("red", "navy"),
    title = gene_name
  ) +
    geom_text_repel(aes(label = rownames(dp))) +
    scale_color_manual(
      name = "Affected Status",
      labels = c("Affected", "Unaffected"),
      values = c("red", "navy")
    )
  print(gene_plot) # Ensure each plot is printed during the loop
  ggsave(
    filename = paste0(gene_name, "-plot-counts.png"),
    path = "output/spta1-analysis/batch-correction-limma/plot-counts/spta1-genes-of-interest",
    plot = gene_plot, dpi = 450, create.dir = TRUE
  )
}

# Create the faceted plot
faceted_plot <- ggplot(gi_all_counts, aes(x = Affected, y = count, color = Affected)) +
  geom_boxplot(alpha = 0.35) +
  geom_jitter(width = 0.2, size = .45) + # Adjust size of the dots
  geom_text_repel(aes(label = SampleID),
    size = 2,
    max.overlaps = Inf, force = 10, color = "black",
    segment.color = "gray",
    min.segment.length = 0,
    point.padding = 0.1
  ) + # Add labels to the dots
  facet_wrap(~Gene, scales = "free_y") +
  theme_bw() +
  labs(title = "Gene Expression Counts by Affected Status", x = "Affected Status", y = "Count") +
  scale_color_manual(values = c("red", "navy")) +
  theme(
    legend.position = "bottom",
    plot.margin = margin(10, 10, 10, 10),
    strip.text = element_text(size = 6), # Adjust facet label text size
    plot.title = element_text(size = 10),
    axis.title = element_text(size = 10),
    axis.text = element_text(size = 6),
    panel.spacing = unit(.35, "lines") # Add space between facets
  ) +
  coord_cartesian(clip = "off") # Ensure labels are not clipped


faceted_plot

# Save the faceted plot
ggsave(
  filename = "faceted_spta1_genes_of_interest_plot_counts.png",
  path = "output/spta1-analysis/batch-correction-limma/plot-counts/spta1-genes-of-interest",
  plot = faceted_plot, dpi = 2200, create.dir = TRUE
)

# Convert the list to a dataframe
gene_results_df <- gene_results_list[[1]]

file_name <- "output/spta1-analysis/spta1_genes_of_interest_plot_counts_signals.csv"
write.csv(gene_results_df, file_name, row.names = FALSE)
```

Below is a heatmap highlighting the expression of our genes of interest across batch, disease group, and affected status.

```{r, heatmap-additional-genes-interest-spta1, out.width = "1200px"}
# Prepare data for the heatmap
mat4 <- assay(vsd_limma)[filtered_with_only_genes$Ensembl_ID, ]
rownames(mat4) <- gene_info$gene_name[match(filtered_with_only_genes$Ensembl_ID, gene_info$Ensembl_ID)]
df <- as.data.frame(colData(vsd_limma)[, c("Affected", "OverallCategory")])

# Set up color palette
color_palette <- colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(50)

# Specify the number of row clusters
num_row_clusters <- 3

png("output/spta1-analysis/spta1_genes_of_interest_heatmap.png", width = 14, height = 10, units = "in", res = 1200)

draw(ComplexHeatmap::pheatmap(
  mat = mat4,
  color = colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(50),
  annotation_col = df,
  annotation_colors = ann_colors,
  fontsize = 6,
  angle_col = c("0"),
  cellheight = 10, # Set cell height
  cellwidth = 24, # Set cell width
  border_color = "black", # Black borders around heatmap cells
  # cutree_rows = num_row_clusters,  # Number of row clusters
  heatmap_legend_param = list(
    title = "Matrix"
  )
))

dev.off()
```

## Only MADD Genes

```{r, generate-plot-counts-genes-interest-madd}
# Create an empty list to store the results for each gene
gene_results_list <- list()

# Create an empty dataframe to store all counts data for plotting
gi_all_counts <- data.frame()

# Loop through each gene to calculate and plot counts
for (ensembl_id in filtered_with_only_madd_genes$Ensembl_ID) {
  d <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  dp <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  gene_name <- filtered_with_only_madd_genes$gene_name[filtered_with_only_madd_genes$Ensembl_ID == ensembl_id]

  # Calculate the mean and standard deviation of counts within each condition
  d_stats <- d %>%
    group_by(Affected) %>%
    summarise(
      mean_count = mean(count),
      sd_count = sd(count)
    )

  # Merge statistics back with the data
  d <- merge(d, d_stats, by = "Affected")

  # Create a temporary dataframe to store results for this gene
  temp_gene_df <- data.frame(
    Patient = rownames(d),
    stringsAsFactors = FALSE
  )

  # Calculate Z-scores and determine regulation status
  regulation_status <- sapply(1:nrow(d), function(i) {
    z_score <- (d$count[i] - d$mean_count[i]) / d$sd_count[i]

    # Determine regulation status based on Z-score
    if (z_score > 1) {
      return("Upregulated")
    } else if (z_score < -1) {
      return("Downregulated")
    } else {
      return("Neutral")
    }
  })

  # Add the regulation status to the temporary dataframe
  temp_gene_df[[gene_name]] <- regulation_status

  # Merge the temporary dataframe with the results list
  if (length(gene_results_list) == 0) {
    gene_results_list[[1]] <- temp_gene_df
  } else {
    gene_results_list[[1]] <- merge(gene_results_list[[1]], temp_gene_df, by = "Patient", all = TRUE)
  }

  # Add the gene name to the dp dataframe
  dp$Gene <- gene_name
  dp$Ensembl_ID <- ensembl_id
  dp$SampleID <- rownames(dp)

  # Combine dp with all_counts dataframe
  gi_all_counts <- rbind(gi_all_counts, dp)

  # Generate the boxplot
  gene_plot <- ggboxplot(dp,
    x = "Affected", y = "count", add = "jitter",
    color = "Affected", palette = c("red", "navy"),
    title = gene_name
  ) +
    geom_text_repel(aes(label = rownames(dp))) +
    scale_color_manual(
      name = "Affected Status",
      labels = c("Affected", "Unaffected"),
      values = c("red", "navy")
    )
  print(gene_plot) # Ensure each plot is printed during the loop
  ggsave(
    filename = paste0(gene_name, "-plot-counts.png"),
    path = "output/spta1-analysis/batch-correction-limma/plot-counts/madd-genes-of-interest",
    plot = gene_plot, dpi = 450, create.dir = TRUE
  )
}

# Create the faceted plot
faceted_plot <- ggplot(gi_all_counts, aes(x = Affected, y = count, color = Affected)) +
  geom_boxplot(alpha = 0.35) +
  geom_jitter(width = 0.2, size = .45) + # Adjust size of the dots
  geom_text_repel(aes(label = SampleID),
    size = 2,
    max.overlaps = Inf, force = 10, color = "black",
    segment.color = "gray",
    min.segment.length = 0,
    point.padding = 0.1
  ) + # Add labels to the dots
  facet_wrap(~Gene, scales = "free_y") +
  theme_bw() +
  labs(title = "Gene Expression Counts by Affected Status", x = "Affected Status", y = "Count") +
  scale_color_manual(values = c("red", "navy")) +
  theme(
    legend.position = "bottom",
    plot.margin = margin(10, 10, 10, 10),
    strip.text = element_text(size = 6), # Adjust facet label text size
    plot.title = element_text(size = 10),
    axis.title = element_text(size = 10),
    axis.text = element_text(size = 6),
    panel.spacing = unit(.35, "lines") # Add space between facets
  ) +
  coord_cartesian(clip = "off") # Ensure labels are not clipped


faceted_plot

# Save the faceted plot
ggsave(
  filename = "faceted_madd_genes_of_interest_plot_counts.png",
  path = "output/spta1-analysis/batch-correction-limma/plot-counts/madd-genes-of-interest",
  plot = faceted_plot, dpi = 2200, create.dir = TRUE
)

# Convert the list to a dataframe
gene_results_df <- gene_results_list[[1]]

file_name <- "output/spta1-analysis/genes_of_interest_plot_counts_signals.csv"
write.csv(gene_results_df, file_name, row.names = FALSE)
```

Below is a heatmap highlighting the expression of our genes of interest across batch, disease group, and affected status.

```{r, heatmap-additional-genes-interest-madd, out.width = "1200px"}
# Prepare data for the heatmap
mat5 <- assay(vsd_limma)[filtered_with_only_madd_genes$Ensembl_ID, ]
rownames(mat5) <- gene_info$gene_name[match(filtered_with_only_madd_genes$Ensembl_ID, gene_info$Ensembl_ID)]
df <- as.data.frame(colData(vsd_limma)[, c("Affected", "OverallCategory")])

# Set up color palette
color_palette <- colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(50)

# Specify the number of row clusters
num_row_clusters <- 3

png("output/spta1-analysis/madd_genes_of_interest_heatmap.png", width = 14, height = 8, units = "in", res = 1200)

draw(ComplexHeatmap::pheatmap(
  mat = mat5,
  color = colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(50),
  annotation_col = df,
  annotation_colors = ann_colors,
  fontsize = 6,
  angle_col = c("0"),
  cellheight = 10, # Set cell height
  cellwidth = 24, # Set cell width
  border_color = "black", # Black borders around heatmap cells
  # cutree_rows = num_row_clusters,  # Number of row clusters
  heatmap_legend_param = list(
    title = "Matrix"
  )
))

dev.off()
```


## Only MITO Genes

```{r, generate-plot-counts-genes-interest-mito}
# Create an empty list to store the results for each gene
gene_results_list <- list()

# Create an empty dataframe to store all counts data for plotting
gi_all_counts <- data.frame()

# Loop through each gene to calculate and plot counts
for (ensembl_id in filtered_with_only_mito_genes$Ensembl_ID) {
  d <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  dp <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  gene_name <- filtered_with_only_mito_genes$gene_name[filtered_with_only_mito_genes$Ensembl_ID == ensembl_id]

  # Calculate the mean and standard deviation of counts within each condition
  d_stats <- d %>%
    group_by(Affected) %>%
    summarise(
      mean_count = mean(count),
      sd_count = sd(count)
    )

  # Merge statistics back with the data
  d <- merge(d, d_stats, by = "Affected")

  # Create a temporary dataframe to store results for this gene
  temp_gene_df <- data.frame(
    Patient = rownames(d),
    stringsAsFactors = FALSE
  )

  # Calculate Z-scores and determine regulation status
  regulation_status <- sapply(1:nrow(d), function(i) {
    z_score <- (d$count[i] - d$mean_count[i]) / d$sd_count[i]

    # Determine regulation status based on Z-score
    if (z_score > 1) {
      return("Upregulated")
    } else if (z_score < -1) {
      return("Downregulated")
    } else {
      return("Neutral")
    }
  })

  # Add the regulation status to the temporary dataframe
  temp_gene_df[[gene_name]] <- regulation_status

  # Merge the temporary dataframe with the results list
  if (length(gene_results_list) == 0) {
    gene_results_list[[1]] <- temp_gene_df
  } else {
    gene_results_list[[1]] <- merge(gene_results_list[[1]], temp_gene_df, by = "Patient", all = TRUE)
  }

  # Add the gene name to the dp dataframe
  dp$Gene <- gene_name
  dp$Ensembl_ID <- ensembl_id
  dp$SampleID <- rownames(dp)

  # Combine dp with all_counts dataframe
  gi_all_counts <- rbind(gi_all_counts, dp)

  # Generate the boxplot
  gene_plot <- ggboxplot(dp,
    x = "Affected", y = "count", add = "jitter",
    color = "Affected", palette = c("red", "navy"),
    title = gene_name
  ) +
    geom_text_repel(aes(label = rownames(dp))) +
    scale_color_manual(
      name = "Affected Status",
      labels = c("Affected", "Unaffected"),
      values = c("red", "navy")
    )
  print(gene_plot) # Ensure each plot is printed during the loop
  ggsave(
    filename = paste0(gene_name, "-plot-counts.png"),
    path = "output/spta1-analysis/batch-correction-limma/plot-counts/mito-genes-of-interest",
    plot = gene_plot, dpi = 450, create.dir = TRUE
  )
}

# Create the faceted plot
faceted_plot <- ggplot(gi_all_counts, aes(x = Affected, y = count, color = Affected)) +
  geom_boxplot(alpha = 0.35) +
  geom_jitter(width = 0.2, size = .45) + # Adjust size of the dots
  geom_text_repel(aes(label = SampleID),
    size = 2,
    max.overlaps = Inf, force = 10, color = "black",
    segment.color = "gray",
    min.segment.length = 0,
    point.padding = 0.1
  ) + # Add labels to the dots
  facet_wrap(~Gene, scales = "free_y") +
  theme_bw() +
  labs(title = "Gene Expression Counts by Affected Status", x = "Affected Status", y = "Count") +
  scale_color_manual(values = c("red", "navy")) +
  theme(
    legend.position = "bottom",
    plot.margin = margin(10, 10, 10, 10),
    strip.text = element_text(size = 6), # Adjust facet label text size
    plot.title = element_text(size = 10),
    axis.title = element_text(size = 10),
    axis.text = element_text(size = 6),
    panel.spacing = unit(.35, "lines") # Add space between facets
  ) +
  coord_cartesian(clip = "off") # Ensure labels are not clipped


faceted_plot

# Save the faceted plot
ggsave(
  filename = "faceted_madd_genes_of_interest_plot_counts.png",
  path = "output/spta1-analysis/batch-correction-limma/plot-counts/mito-genes-of-interest",
  plot = faceted_plot, dpi = 2200, create.dir = TRUE
)

# Convert the list to a dataframe
gene_results_df <- gene_results_list[[1]]

file_name <- "output/spta1-analysis/mito_genes_of_interest_plot_counts_signals.csv"
write.csv(gene_results_df, file_name, row.names = FALSE)
```

Below is a heatmap highlighting the expression of our genes of interest across batch, disease group, and affected status.

```{r, heatmap-additional-genes-interest-mito, out.width = "1200px"}
# Prepare data for the heatmap
mat6 <- assay(vsd_limma)[filtered_with_only_mito_genes$Ensembl_ID, ]
rownames(mat6) <- gene_info$gene_name[match(filtered_with_only_mito_genes$Ensembl_ID, gene_info$Ensembl_ID)]
df <- as.data.frame(colData(vsd_limma)[, c("Affected", "OverallCategory")])

# Set up color palette
color_palette <- colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(50)

# Specify the number of row clusters
num_row_clusters <- 3

png("output/spta1-analysis/mito_genes_of_interest_heatmap.png", width = 14, height = 8, units = "in", res = 1200)

draw(ComplexHeatmap::pheatmap(
  mat = mat6,
  color = colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(50),
  annotation_col = df,
  annotation_colors = ann_colors,
  fontsize = 6,
  angle_col = c("0"),
  cellheight = 10, # Set cell height
  cellwidth = 24, # Set cell width
  border_color = "black", # Black borders around heatmap cells
  # cutree_rows = num_row_clusters,  # Number of row clusters
  heatmap_legend_param = list(
    title = "Matrix"
  )
))

dev.off()
```

## Significant Genes Plot Counts

```{r, generate-plot-counts-genes-significant}
# Create an empty list to store the results for each gene
results_list <- list()

# Create an empty dataframe to store all counts data for plotting
all_counts <- data.frame()

res_aff_vs_unaff_df_genename_05 <- subset(res_aff_vs_unaff_df_genename, padj < 0.05)
res_aff_vs_unaff_df_genename_05 <- res_aff_vs_unaff_df_genename_05[order(res_aff_vs_unaff_df_genename_05$padj), ]

res_aff_vs_unaff_df_genename_padj05_lfc1 <- subset(res_aff_vs_unaff_df_genename_05, log2FoldChange >= 1 | log2FoldChange <= -1)
res_aff_vs_unaff_df_genename_padj05_lfc1 <- res_aff_vs_unaff_df_genename_padj05_lfc1[order(res_aff_vs_unaff_df_genename_padj05_lfc1$padj), ]

# Loop through each gene to calculate and plot counts
for (ensembl_id in res_aff_vs_unaff_df_genename_padj05_lfc1$Ensembl_ID) {
  dp <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  d <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  gene_name <- res_aff_vs_unaff_df_genename_padj05_lfc1$gene_name[res_aff_vs_unaff_df_genename_padj05_lfc1$Ensembl_ID == ensembl_id]

  # Calculate the mean and standard deviation of counts within each condition
  d_stats <- d %>%
    group_by(Affected) %>%
    summarise(
      mean_count = mean(count),
      sd_count = sd(count)
    )

  # Merge statistics back with the data
  d <- merge(d, d_stats, by = "Affected")

  # Create a temporary dataframe to store results for this gene
  temp_df <- data.frame(
    Patient = rownames(d),
    stringsAsFactors = FALSE
  )

  # Calculate Z-scores and determine regulation status
  regulation_status <- sapply(1:nrow(d), function(i) {
    if (is.na(d$sd_count[i]) || d$sd_count[i] == 0) {
      return("Neutral")
    }

    z_score <- (d$count[i] - d$mean_count[i]) / d$sd_count[i]

    # Determine regulation status based on Z-score
    if (is.na(z_score)) {
      return("Neutral")
    } else if (z_score > 1) {
      return("Upregulated")
    } else if (z_score < -1) {
      return("Downregulated")
    } else {
      return("Neutral")
    }
  })

  # Add the regulation status to the temporary dataframe
  temp_df[[gene_name]] <- regulation_status

  # Merge the temporary dataframe with the results list
  if (length(results_list) == 0) {
    results_list[[1]] <- temp_df
  } else {
    results_list[[1]] <- merge(results_list[[1]], temp_df, by = "Patient", all = TRUE)
  }

  # Add the gene name to the dp dataframe
  dp$Gene <- gene_name
  dp$Ensembl_ID <- ensembl_id
  dp$SampleID <- rownames(dp)

  # Combine dp with all_counts dataframe
  all_counts <- rbind(all_counts, dp)

  # Generate the boxplot
  ggplot_box <- ggboxplot(dp,
    x = "Affected", y = "count", add = "jitter",
    color = "Affected", palette = c("red", "navy"),
    title = gene_name
  ) +
    geom_text_repel(aes(label = rownames(dp))) +
    scale_color_manual(
      name = "Affected Status",
      labels = c("Affected", "Unaffected"),
      values = c("red", "navy")
    )
  print(ggplot_box) # Ensure each plot is printed during the loop
  ggsave(
    filename = paste0(gene_name, "-plot-counts.png"),
    path = "output/spta1-analysis/batch-correction-limma/plot-counts/padj-05",
    plot = ggplot_box, dpi = 450, create.dir = TRUE
  )
}

# Create the faceted plot
faceted_plot <- ggplot(all_counts, aes(x = Affected, y = count, color = Affected)) +
  geom_boxplot(alpha = 0.4) +
  geom_jitter(width = 0.2, size = 1.25) + # Adjust size of the dots
  geom_text_repel(aes(label = SampleID),
    size = 2,
    max.overlaps = Inf, force = 10, color = "black",
    segment.color = "gray",
    min.segment.length = 0,
    point.padding = 0.1
  ) + # Add labels to the dots
  facet_wrap(~Gene, scales = "free_y") +
  theme_bw() +
  labs(title = "Gene Expression Counts by Affected Status", x = "Affected Status", y = "Count") +
  scale_color_manual(values = c("red", "navy")) +
  theme(
    legend.position = "bottom",
    plot.margin = margin(10, 10, 10, 10),
    strip.text = element_text(size = 8), # Adjust facet label text size
    plot.title = element_text(size = 14),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    panel.spacing = unit(1, "lines") # Add space between facets
  ) +
  coord_cartesian(clip = "off") # Ensure labels are not clipped


faceted_plot

# Save the faceted plot
ggsave(
  filename = "faceted_significant_degs_plot_counts.png",
  path = "output/spta1-analysis/batch-correction-limma/plot-counts/padj-05",
  plot = faceted_plot, dpi = 1200, create.dir = TRUE
)

# Convert the list to a dataframe
results_df <- results_list[[1]]

file_name <- "output/spta1-analysis/significant_plot_counts_signals.csv"
write.csv(results_df, file_name, row.names = FALSE)
```

### Save data

```{r, save-data}
save.image(file = "output/spta1-analysis/spta1-condition-analysis.RData")
```

