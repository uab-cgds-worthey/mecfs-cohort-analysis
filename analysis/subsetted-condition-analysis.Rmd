---
title: "Subsetted Differential Gene Expression (DGE) Analysis"
output:
  workflowr::wflow_html:
    toc: true
    toc_depth: 3
    toc_float: true
    code_folding: hide
editor_options:
  chunk_output_type: console
---

```{r, setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# Load libraries

Ensure you have followed instructions in the readme on activating the renv environment.

```{r, load libraries, warning = FALSE, message = FALSE}
library(tidyverse) # Available via CRAN
library(DESeq2) # Available via Bioconductor
library(RColorBrewer) # Available via CRAN
library(pheatmap) # Available via CRAN
library(genefilter) # Available via Bioconductor
library(limma) # Available via Bioconductor
library(gprofiler2) # Available via CRAN
library(biomaRt) # Available via Bioconductor
library(plotly) # Available via CRAN
library(ggpubr) # Available via CRAN
library(rmarkdown) # Available via CRAN
library(clusterProfiler) # Available via Bioconductor
library(org.Hs.eg.db) # Available via Bioconductor
library(ggrepel) # Available via CRAN
library(ReactomePA) # Available via Bioconductor
library(mygene) # Available via Bioconductor
library(DOSE) # Available via Bioconductor
library(enrichR) # Available via Bioconductor
library(STRINGdb) # Available via Bioconductor
library(EnhancedVolcano)
library(ComplexHeatmap)
```

```{r, include=FALSE}
source("code/helpers.R", local = knitr::knit_global())
# or sys.source("your-script.R", envir = knitr::knit_global())
```

## Data Import

We will be importing counts data from the star-salmon pipeline and our metadata 
for the project which is hosted on Box. This also ensures data is properly ordered by sample id.

```{r, import data}
counts <- read_tsv("data/star-salmon/salmon.merged.gene_counts_length_scaled.tsv")

# Import variants of interest
genes_of_interest <- read_csv("data/Prioritized_Genes_From_WGS_2024_11_19.csv")
genes_of_interest <- unique(genes_of_interest$Genes)
genes_of_interest <- genes_of_interest[!is.na(genes_of_interest)]

# Use first column (gene_id) for row names
counts <- data.frame(counts, row.names = 1)
counts$Ensembl_ID <- row.names(counts)
drop <- c("Ensembl_ID", "gene_name")
gene_info <- counts[, drop]
counts <- counts[, !(names(counts) %in% drop)] # remove both columns

# Import metadata
sample_metadata <- read_csv("data/Metadata_2024_11_20.csv")
row.names(sample_metadata) <- sample_metadata$ID

# Assuming counts is your counts dataframe and sample_metadata is your metadata dataframe
# Call the function with the appropriate column names
counts <- rename_counts_columns(counts, sample_metadata, "ID", "RNA_Samples_id")

# Check that data is ordered properly
sample_metadata <- check_order(sample_metadata = sample_metadata, counts = counts)

genes_biomart <- retrieve_gene_info(values = gene_info$Ensembl_ID, filters = "ensembl_gene_id_version")
```

## DESeq2 Analysis

```{r, start analysis}
sample_metadata$Family <- factor(sample_metadata$Family)
sample_metadata$Affected <- factor(sample_metadata$Affected)
sample_metadata$Batch <- factor(sample_metadata$Batch)
sample_metadata$Sex <- factor(sample_metadata$Sex)
sample_metadata$Ancestry <- factor(sample_metadata$Ancestry)
sample_metadata$Category <- factor(sample_metadata$Category)
sample_metadata$OverallCategory <- factor(sample_metadata$`Overall category assigned`)

# Account for Batch and Affected Status
dds <- DESeqDataSetFromMatrix(
  countData = round(counts), colData = sample_metadata,
  design = ~ Batch + Affected
)

# Pre-filtering: Keep only rows that have at least 10 reads total
keep <- rowSums(counts(dds)) >= 50
dds <- dds[keep, ]

# Remove samples from families with multiple samples
# View Excluded_Samples.csv to learn why these were excluded
remove_multiple_fam <- c("8", "12", "19", "21", "23", "27")

# Save excluded/removed samples
# Code is commented out since this is for 1 time usage
# excluded_samples_df <- filter(sample_metadata,
#                        ID %in% remove_multiple_fam)
# write.csv(excluded_samples_df, "data/Excluded_Samples.csv")

# Create a logical vector to index the columns you want to keep
kept_fam_members <- !(colnames(dds) %in% remove_multiple_fam)
dds <- dds[, kept_fam_members]

# Run DESeq function
dds <- DESeq(dds)

# Normalize gene counts for differences in seq. depth/global differences
counts_norm <- counts(dds, normalized = TRUE)
```

### Data transformation and visualization

Perform count data transformation by variance stabilizing transformation (vst) on normalized counts.

```{r, vsd}
vsd <- vst(dds, blind = FALSE)
```

### Batch correction with limma

```{r, limma}
counts_vst <- assay(vsd)
write.csv(counts_vst, file = "output/publication-analysis/counts_vst_subsetted.csv")
mm <- model.matrix(~ Batch + Affected, colData(vsd))

counts_vst_limma <- limma::removeBatchEffect(counts_vst, batch = vsd$Batch, 
                                             design = mm)

write.csv(counts_vst_limma, file = "output/publication-analysis/counts_vst_limma_subsetted.csv")

vsd_limma <- vsd
assay(vsd_limma) <- counts_vst_limma
```

### Sample distances heatmap

```{r, sample-dist-heatmap}
sample_dists_all <- dist(t(assay(vsd_limma)))
sample_dist_matrix_all <- as.matrix(sample_dists_all)
rownames(sample_dist_matrix_all) <- paste(vsd_limma$Batch, vsd_limma$Affected, 
                                          sep = " | ")
colnames(sample_dist_matrix_all) <- paste(vsd_limma$ID, vsd_limma$Affected, 
                                          sep = " | ")
colors <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)

pheatmap(sample_dist_matrix_all, clustering_distance_rows = sample_dists_all, 
         clustering_distance_cols = sample_dists_all, col = colors)
```

### Principal Components Analysis

Our below PCA shows that there does not seem to be a batch-related effect 
occurring after using limma. However, we can see that our 3 male samples are 
grouping. Given this knowledge, removing them from downstream analyses is the best option.

```{r, principal-components-analysis-all}
pca_data_all <- plotPCA(vsd_limma, intgroup = c("Batch", "Affected", "Sex"), 
                        returnData = TRUE)
percent_var_all <- round(100 * attr(pca_data_all, "percentVar"))

ggplot(pca_data_all, aes(PC1, PC2)) +
  geom_point(aes(colour = Affected, fill = Sex, shape = Batch), size = 4) +
  scale_shape_manual(values = c(21, 22, 23)) +
  scale_fill_manual(values = c("white", "gray")) +
  scale_color_manual(values = c("blue", "red")) +
  geom_text(aes(label = name),
    data = subset(pca_data_all, PC2 < -18 | PC1 < -30),
    vjust = -1, hjust = 0.5, size = 2.5
  ) +
  xlab(paste0("PC1: ", percent_var_all[1], "% variance")) +
  ylab(paste0("PC2: ", percent_var_all[2], "% variance")) +
  coord_fixed()
```

```{r, principal-components-analysis-overallcategory}
pca_data_all <- plotPCA(vsd_limma, intgroup = c("Affected", "Sex", 
                                                "OverallCategory"),
                        returnData = TRUE)
percent_var_all <- round(100 * attr(pca_data_all, "percentVar"))

ggplot(pca_data_all, aes(PC1, PC2)) +
  geom_point(aes(colour = Category, fill = Sex, shape = Affected), size = 4) +
  geom_text(aes(label = name), vjust = -1, hjust = 0.65, size = 5) +
  # geom_text_repel(aes(label = name), size = 5, vjust = -1, hjust = -0.65) +
  xlab(paste0("PC1: ", percent_var_all[1], "% variance")) +
  ylab(paste0("PC2: ", percent_var_all[2], "% variance")) +
  coord_fixed()
```

### Heatmap of all genes, top 50  & top 100 genes

```{r, heatmap-colors, out.height="570px", out.width ="800px"}
# Specify annotation colors by columns
# Use RColorBrewer::brewer.pal(n=10, name="Set1")
overall_category_colors <- c(
  "ENE" = "#BFDFBF", # Magenta
  "IMM" = "#EEBFEE", # Light green
  "SOL" = "#FFFF33", # Mustard yellow
  "STR" = "#BFBFFF", # Brown
  "N/A" = "darkgray" # Dark grey
)


ann_colors <- list(
  Batch = c(B1 = "purple", B2 = "firebrick", B3 = "yellow"),
  Affected = c(Affected = "green", Unaffected = "navy"),
  SubCategory = category_colors,
  Category = combined_category_colors,
  OverallCategory = overall_category_colors
)
```

This is a heatmap of the top 50 genes with the highest variance across samples

```{r, top50-heatmap-batch-combined, out.height="570px", out.width ="800px"}
top_var_genes <- head(order(-rowVars(assay(vsd_limma))), 50)
mat <- assay(vsd_limma)[top_var_genes, ]
mat <- mat - rowMeans(mat)
df <- as.data.frame(colData(vsd_limma)[, c("Batch", "Affected", "Category")])

ensembl_to_gene <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)

# Get the current row names of the matrix 'mat'
current_ensembl_ids <- rownames(mat)

# Find the corresponding gene names for the Ensembl IDs
new_row_names <- ensembl_to_gene[current_ensembl_ids]

# Set the new row names for the matrix 'mat'
rownames(mat) <- new_row_names

ComplexHeatmap::pheatmap(mat,
  annotation_col = df, annotation_colors = ann_colors2,
  fontsize = 5, angle_col = c("0")
)
```

This is a heatmap of the top 50 genes with the highest variance across all samples.

```{r, top50-heatmap-subsetted, out.height="570px", out.width ="800px"}
top_var_genes_all <- head(order(-rowVars(assay(vsd_limma))), 50)
mat_all <- assay(vsd_limma)[top_var_genes_all, ]
mat_all <- mat_all - rowMeans(mat_all)
df_all <- as.data.frame(colData(vsd_limma)[, c("Batch", "Affected", "SubCategory")])
df_affcat <- as.data.frame(colData(vsd_limma)[, c("Affected", "Category")])

ensembl_to_gene <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)

# Get the current row names of the matrix 'mat'
current_ensembl_ids_all <- rownames(mat_all)

# Find the corresponding gene names for the Ensembl IDs
new_row_names_all <- ensembl_to_gene[current_ensembl_ids_all]

# Set the new row names for the matrix 'mat'
rownames(mat_all) <- new_row_names_all

pheatmap(mat_all, annotation_col = df_all, annotation_colors = ann_colors, 
         fontsize = 5)

pheatmap(mat_all, annotation_col = df_affcat, annotation_colors = ann_colors2, 
         fontsize = 5)
```

This is a heatmap of the top 100 genes with the highest variance across
```{r, top100-heatmap-subsetted, out.width = "1200px"}
top_var_genes_100_all <- head(order(-rowVars(assay(vsd_limma))), 100)
mat_100_all <- assay(vsd_limma)[top_var_genes_100_all, ]
mat_100_all <- mat_100_all - rowMeans(mat_100_all)
df_100_all <- as.data.frame(colData(vsd_limma)[, c("Affected", "SubCategory")])

ensembl_to_gene <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)

# Get the current row names of the matrix 'mat'
current_ensembl_ids_100_all <- rownames(mat_100_all)

# Find the corresponding gene names for the Ensembl IDs
new_row_names_100_all <- ensembl_to_gene[current_ensembl_ids_100_all]

# Set the new row names for the matrix 'mat'
rownames(mat_100_all) <- new_row_names_100_all

pheatmap(mat_100_all, annotation_col = df_100_all, 
         annotation_colors = ann_colors2, fontsize = 6)
```

### Comparison/Contrast of Affected_Affected_vs_Unaffected 

```{r}
res_aff_vs_unaff_sub <- results(dds, contrast = c("Affected", "Affected", "Unaffected"))
res_aff_vs_unaff_df_sub <- process_and_save_results(
  res_aff_vs_unaff_sub,
  "output/res_aff_vs_unaff_sub.csv"
)
res_aff_vs_unaff_df_sub <- arrange(res_aff_vs_unaff_df_sub, padj)
res_aff_vs_unaff_df_05_sub <- subset(res_aff_vs_unaff_df_sub, padj < 0.05)
res_aff_vs_unaff_df_1_sub <- subset(res_aff_vs_unaff_df_sub, padj < 0.1)

res_aff_vs_unaff_df_padj1_lfc1_sub <- subset(res_aff_vs_unaff_df_1_sub, log2FoldChange >= 1 | log2FoldChange <= -1)

res_aff_vs_unaff_df_padj05_lfc1_sub <- subset(res_aff_vs_unaff_df_05_sub, log2FoldChange >= 1 | log2FoldChange <= -1)

summary(res_aff_vs_unaff_sub)
```

```{r, top-100-genes-deseq-subsetted, out.height="570px", out.width ="800px"}
topgenes_byensemblid_sub <- head(rownames(res_aff_vs_unaff_df_sub), 100)
topgenes_aff_vs_unaff_05_sub <- assay(vsd_limma)[topgenes_byensemblid_sub, ]
topgenes_aff_vs_unaff_05_sub <- topgenes_aff_vs_unaff_05_sub - rowMeans(topgenes_aff_vs_unaff_05_sub)

ensembl_to_gene_sub <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)

# Get the current row names of the matrix 'mat'
current_ensembl_ids_sub <- rownames(topgenes_aff_vs_unaff_05_sub)

# Find the corresponding gene names for the Ensembl IDs
new_row_names_sub <- ensembl_to_gene_sub[current_ensembl_ids_sub]

# Set the new row names for the matrix 'mat'
rownames(topgenes_aff_vs_unaff_05_sub) <- new_row_names_sub

topgenes_aff_vs_unaff_05_sub <- topgenes_aff_vs_unaff_05_sub[order(row.names(topgenes_aff_vs_unaff_05_sub)), ]

df_sub <- as.data.frame(colData(vsd_limma)[, c("Affected", "Category")])
pheatmap(topgenes_aff_vs_unaff_05_sub, annotation_col = df_sub, annotation_colors = ann_colors2, fontsize = 5, angle_col = c("0"))
```

```{r, top-100-genes-deseq-subsetted-subcategory, out.height="570px", out.width ="800px"}
topgenes_byensemblid_sub <- head(rownames(res_aff_vs_unaff_df_sub), 100)
topgenes_aff_vs_unaff_05_sub <- assay(vsd_limma)[topgenes_byensemblid_sub, ]
topgenes_aff_vs_unaff_05_sub <- topgenes_aff_vs_unaff_05_sub - rowMeans(topgenes_aff_vs_unaff_05_sub)

ensembl_to_gene_sub <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)

# Get the current row names of the matrix 'mat'
current_ensembl_ids_sub <- rownames(topgenes_aff_vs_unaff_05_sub)

# Find the corresponding gene names for the Ensembl IDs
new_row_names_sub <- ensembl_to_gene_sub[current_ensembl_ids_sub]

# Set the new row names for the matrix 'mat'
rownames(topgenes_aff_vs_unaff_05_sub) <- new_row_names_sub

topgenes_aff_vs_unaff_05_sub <- topgenes_aff_vs_unaff_05_sub[order(row.names(topgenes_aff_vs_unaff_05_sub)), ]

df_sub <- as.data.frame(colData(vsd_limma)[, c("Affected", "SubCategory", "Category")])
pheatmap(topgenes_aff_vs_unaff_05_sub, annotation_col = df_sub, annotation_colors = ann_colors2, fontsize = 5, angle_col = c("0"))
```


```{r, top-50-genes-deseq-subsetted, out.height="570px", out.width ="800px"}
topgenes_byensemblid_sub <- head(rownames(res_aff_vs_unaff_df_sub), 50)
topgenes_aff_vs_unaff_05_sub <- assay(vsd_limma)[topgenes_byensemblid_sub, ]
topgenes_aff_vs_unaff_05_sub <- topgenes_aff_vs_unaff_05_sub - rowMeans(topgenes_aff_vs_unaff_05_sub)

ensembl_to_gene_sub <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)

# Get the current row names of the matrix 'mat'
current_ensembl_ids_sub <- rownames(topgenes_aff_vs_unaff_05_sub)

# Find the corresponding gene names for the Ensembl IDs
new_row_names_sub <- ensembl_to_gene_sub[current_ensembl_ids_sub]

# Set the new row names for the matrix 'mat'
rownames(topgenes_aff_vs_unaff_05_sub) <- new_row_names_sub

topgenes_aff_vs_unaff_05_sub <- topgenes_aff_vs_unaff_05_sub[order(row.names(topgenes_aff_vs_unaff_05_sub)), ]

df_sub <- df <- colData(vsd_limma) %>%
  as.data.frame() %>%
  dplyr::select(Category)
pheatmap(topgenes_aff_vs_unaff_05_sub, annotation_col = df_sub, annotation_colors = ann_colors2, fontsize = 5, angle_col = c("0"))
```

```{r, top-50-genes-deseq-subsetted-subcategory, out.height="570px", out.width ="800px"}
topgenes_byensemblid_sub <- head(rownames(res_aff_vs_unaff_df_sub), 50)
topgenes_aff_vs_unaff_05_sub <- assay(vsd_limma)[topgenes_byensemblid_sub, ]
topgenes_aff_vs_unaff_05_sub <- topgenes_aff_vs_unaff_05_sub - rowMeans(topgenes_aff_vs_unaff_05_sub)

ensembl_to_gene_sub <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)

# Get the current row names of the matrix 'mat'
current_ensembl_ids_sub <- rownames(topgenes_aff_vs_unaff_05_sub)

# Find the corresponding gene names for the Ensembl IDs
new_row_names_sub <- ensembl_to_gene_sub[current_ensembl_ids_sub]

# Set the new row names for the matrix 'mat'
rownames(topgenes_aff_vs_unaff_05_sub) <- new_row_names_sub

topgenes_aff_vs_unaff_05_sub <- topgenes_aff_vs_unaff_05_sub[order(row.names(topgenes_aff_vs_unaff_05_sub)), ]

df_sub <- df <- colData(vsd_limma) %>%
  as.data.frame() %>%
  dplyr::select(Affected, SubCategory, Category)
pheatmap(topgenes_aff_vs_unaff_05_sub,
  annotation_col = df_sub,
  annotation_colors = ann_colors2, fontsize = 5, angle_col =c("0")
)
```

## Heatmap of Significant Genes


```{r, significant-genes-deseq-subsetted-overallcategory-lfc1, out.height="570px", out.width ="800px"}
topgenes_byensemblid_sub <- rownames(res_aff_vs_unaff_df_padj1_lfc1_sub)
topgenes_aff_vs_unaff_05_sub <- assay(vsd_limma)[topgenes_byensemblid_sub, ]
topgenes_aff_vs_unaff_05_sub <- topgenes_aff_vs_unaff_05_sub - rowMeans(topgenes_aff_vs_unaff_05_sub)

ensembl_to_gene_sub <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)

# Get the current row names of the matrix 'mat'
current_ensembl_ids_sub <- rownames(topgenes_aff_vs_unaff_05_sub)

# Find the corresponding gene names for the Ensembl IDs
new_row_names_sub <- ensembl_to_gene_sub[current_ensembl_ids_sub]

# Set the new row names for the matrix 'mat'
rownames(topgenes_aff_vs_unaff_05_sub) <- new_row_names_sub

topgenes_aff_vs_unaff_05_sub <- topgenes_aff_vs_unaff_05_sub[order(row.names(topgenes_aff_vs_unaff_05_sub)), ]

df_sub <- df <- colData(vsd_limma) %>%
  as.data.frame() %>%
  dplyr::select(Affected, OverallCategory)

significant_genes_df <- topgenes_aff_vs_unaff_05_sub

png("output/publication-analysis/Supplemental Figure 4. DEGs (Padj < 0.1).png",width=12,height=10,units="in",res=1200)

draw(ComplexHeatmap::pheatmap(topgenes_aff_vs_unaff_05_sub, color = colorRampPalette(rev(brewer.pal(n = 9, name =
  "RdYlBu")))(50), annotation_col = df_sub, annotation_colors = ann_colors, fontsize = 6, angle_col = c("0"), cellheight = 10, cellwidth = 24, border_color = "black", heatmap_legend_param = list(
        title = "Matrix"
    )))
dev.off()
```

```{r, significant-genes-deseq-subsetted-overallcategory-padj05-lfc1, out.height="570px", out.width ="800px"}
topgenes_byensemblid_sub <- rownames(res_aff_vs_unaff_df_padj05_lfc1_sub)
topgenes_aff_vs_unaff_05_sub <- assay(vsd_limma)[topgenes_byensemblid_sub, ]
topgenes_aff_vs_unaff_05_sub <- topgenes_aff_vs_unaff_05_sub - rowMeans(topgenes_aff_vs_unaff_05_sub)

ensembl_to_gene_sub <- setNames(gene_info$gene_name, gene_info$Ensembl_ID)

# Get the current row names of the matrix 'mat'
current_ensembl_ids_sub <- rownames(topgenes_aff_vs_unaff_05_sub)

# Find the corresponding gene names for the Ensembl IDs
new_row_names_sub <- ensembl_to_gene_sub[current_ensembl_ids_sub]

# Set the new row names for the matrix 'mat'
rownames(topgenes_aff_vs_unaff_05_sub) <- new_row_names_sub

topgenes_aff_vs_unaff_05_sub <- topgenes_aff_vs_unaff_05_sub[order(row.names(topgenes_aff_vs_unaff_05_sub)), ]

df_sub <- df <- colData(vsd_limma) %>%
  as.data.frame() %>%
  dplyr::select(Affected, OverallCategory)

significant_genes_df <- topgenes_aff_vs_unaff_05_sub

png("output/publication-analysis/Supplemental Figure 4. Significant DEGs.png",width=12,height=10,units="in",res=1200)

draw(ComplexHeatmap::pheatmap(topgenes_aff_vs_unaff_05_sub, color = colorRampPalette(rev(brewer.pal(n = 9, name =
  "RdYlBu")))(50), annotation_col = df_sub, annotation_colors = ann_colors, fontsize = 6, angle_col = c("0"), cellheight = 10, cellwidth = 24, border_color = "black", heatmap_legend_param = list(
        title = "Matrix"
    )))
dev.off()
```


```{r, all-genes-list-subsetted}
gb_df <- genes_biomart[, c(1, ncol(genes_biomart))]
res_aff_vs_unaff_df_sub_genename <- res_aff_vs_unaff_df_sub
res_aff_vs_unaff_df_sub_genename$Ensembl_ID <- row.names(res_aff_vs_unaff_df_sub)
res_aff_vs_unaff_df_sub_genename <- merge(x = res_aff_vs_unaff_df_sub_genename, y = gene_info, by.x = "Ensembl_ID", by.y = "Ensembl_ID", all.x = TRUE)
res_aff_vs_unaff_df_sub_genename <- res_aff_vs_unaff_df_sub_genename[, c(dim(res_aff_vs_unaff_df_sub_genename)[2], 1:dim(res_aff_vs_unaff_df_sub_genename)[2] - 1)]
res_aff_vs_unaff_df_sub_genename <- res_aff_vs_unaff_df_sub_genename[order(res_aff_vs_unaff_df_sub_genename[, "padj"]), ]
write.csv(res_aff_vs_unaff_df_sub_genename, file = "output/publication-analysis/res_aff_vs_unaff_df_sub_genename.csv")
```

## Volcano Plot
```{r, volcano-plot, out.height="1000px", out.width ="1600px"}
ev <- EnhancedVolcano(res_aff_vs_unaff_df_sub_genename,
                      lab = res_aff_vs_unaff_df_sub_genename$gene_name,
                      x = 'log2FoldChange',
                      y = 'padj',
                      selectLab = c('SLC4A10','SNTG2','KCNQ5','DEFA1', 
                                    'CD248', 'POLR3G', 'ZNF683'),
                      xlab = bquote(~Log[2]~ 'fold change'),
                      ylab = bquote(~Log[10]~ 'padj'),
                      pCutoff = .05,
                      FCcutoff = 1.0,
                      pointSize = 2.0,
                      labSize = 4.0,
                      labCol = 'black',
                      labFace = 'bold',
                      boxedLabels = TRUE,
                      colAlpha = 4/5,
                      legendPosition = 'bottom',
                      legendLabSize = 14,
                      legendIconSize = 4.0,
                      drawConnectors = TRUE,
                      widthConnectors = 1.0,
                      colConnectors = 'black',
                      legendLabels = c(" NS", bquote(~Log[2]~ 'fold change'), " padj", 
                                       bquote(~Log[2]~ 'fold change and padj')),
                      title = 'Affected versus Unaffected',
                      subtitle = "Differential Gene Expression Analysis in ME/CFS Patients")

ev <- ev + ggplot2::coord_cartesian(xlim=c(-25, 25)) + 
  ggplot2::scale_x_continuous(breaks=seq(-25,25, 5)) + 
  ggplot2::scale_y_continuous(breaks=seq(0,7, 1))
ggsave(plot = ev, filename = "output/publication-analysis/subsetted-analysis-volcano-plot.png", device = "png", width = 14, dpi = 1200, units = "in")
```


```{r, significant-with-genename-padj-lfc}
res_aff_vs_unaff_df_genename_05 <- subset(res_aff_vs_unaff_df_sub_genename, padj < 0.05)
res_aff_vs_unaff_df_genename_05 <- res_aff_vs_unaff_df_genename_05[order(res_aff_vs_unaff_df_genename_05$padj), ]
write.csv(res_aff_vs_unaff_df_genename_05, file = "output/publication-analysis/res_aff_vs_unaff_df_sub_genename_05.csv")

res_aff_vs_unaff_df_genename_padj05_lfc1 <- subset(res_aff_vs_unaff_df_genename_05, log2FoldChange >= 1 | log2FoldChange <= -1)
res_aff_vs_unaff_df_genename_padj05_lfc1 <- res_aff_vs_unaff_df_genename_padj05_lfc1[order(res_aff_vs_unaff_df_genename_padj05_lfc1$padj), ]
write.csv(res_aff_vs_unaff_df_genename_padj05_lfc1, file = "output/publication-analysis/res_aff_vs_unaff_df_sub_genename_padj05_lfc1.csv")


res_aff_vs_unaff_df_genename_1 <- subset(res_aff_vs_unaff_df_sub_genename, padj < 0.1)
res_aff_vs_unaff_df_genename_1 <- res_aff_vs_unaff_df_genename_1[order(res_aff_vs_unaff_df_genename_1$padj), ]
write.csv(res_aff_vs_unaff_df_genename_1, file = "output/publication-analysis/res_aff_vs_unaff_df_sub_genename_padj1.csv")

res_aff_vs_unaff_df_genename_padj1_lfc1 <- subset(res_aff_vs_unaff_df_genename_1, log2FoldChange >= 1 | log2FoldChange <= -1)
res_aff_vs_unaff_df_genename_padj1_lfc1 <- res_aff_vs_unaff_df_genename_padj1_lfc1[order(res_aff_vs_unaff_df_genename_padj1_lfc1$padj), ]
write.csv(res_aff_vs_unaff_df_genename_padj1_lfc1, file = "output/publication-analysis/res_aff_vs_unaff_df_sub_genename_padj1_lfc1.csv")
```

Below is a table of information about the top genes.

```{r, padj-gene-info-subsetted}
genes <- res_aff_vs_unaff_df_genename_05$gene_name
my_gene_data <- queryMany(genes, scopes = "symbol", fields = c("symbol", "name", "summary", species = "human"))
my_gene_data_unique <- as.data.frame(my_gene_data) %>% dplyr::distinct(query, .keep_all = TRUE)
# paged_table(my_gene_data, options = list(rows.print = 15))
```

```{r, maplot-subsetted-samples}
filtered_gene_names <- res_aff_vs_unaff_df_sub_genename$gene_name[!grepl("^ENS", res_aff_vs_unaff_df_sub_genename$gene_name)]
# Select specific genes to show
# set top = 0, then specify genes using label.select argument
maplot <- ggmaplot(res_aff_vs_unaff_df_sub,
  main = "Affected vs Unaffected MA Plot",
  fdr = .1, fc = 1, size = 0.4, # Same used for others.
  genenames = as.vector(res_aff_vs_unaff_df_sub_genename$gene_name),
  ggtheme = ggplot2::theme_minimal(),
  legend = "top", top = 30,
  font.label = c("bold", 6), label.rectangle = TRUE,
  font.legend = "bold", font.main = "bold"
)

maplot

significant_data <- maplot$data %>%
  filter(grepl("Up|Down", sig)) %>%
  mutate(direction = ifelse(grepl("Up", sig), "Up", "Down")) %>%
  dplyr::select(-sig) # This removes the 'sig' column

# Combine DataFrames based on matching 'query' in my_gene_data_unique to 'gene' in significant_data
combined_data <- inner_join(my_gene_data_unique, significant_data, by = c("query" = "name"))

combined_data <- combined_data %>%
  dplyr::select(-notfound, -X_id, -X_score) %>%
  rename(gene = query)

paged_table(as.data.frame(significant_data), options = list(rows.print = 30))
# Save significant genes
write.csv(significant_data, file = "output/publication-analysis/res_aff_vs_unaff_significant_subsetted_samples.csv", row.names = FALSE)

# Save significant genes
write.csv(combined_data, file = "output/publication-analysis/res_aff_vs_unaff_significant_subsetted_mygene.csv", row.names = FALSE)
```

## Expression of Candidate Genes

Below is a table of expression of the genes identified during our WGS analysis.

```{r, genes-of-interest-table-subsetted}
# Subset gene_info using genes of interest
subset_gene_info <- gene_info[gene_info$gene_name %in% genes_of_interest, ]

filtered_by_interest <- filter(res_aff_vs_unaff_df_sub_genename, Ensembl_ID %in% subset_gene_info$Ensembl_ID)

# Filtering the dataframe by row names
filtered_counts <- counts[row.names(counts) %in% subset_gene_info$Ensembl_ID, ]

# Match and update row names
matching_indices <- match(rownames(filtered_counts), subset_gene_info$Ensembl_ID)

# Update row names based on matching_column values from metadata
rownames(filtered_counts) <- subset_gene_info$gene_name[matching_indices]

missing_genes <- setdiff(subset_gene_info$Ensembl_ID, filtered_by_interest$Ensembl_ID)

corresponding_gene_names <- subset_gene_info$gene_name[subset_gene_info$Ensembl_ID %in% missing_genes]

missing_gene_counts <- counts[row.names(counts) %in% missing_genes, ]

paged_table(filtered_by_interest, options = list(rows.print = 15))

paged_table(filtered_counts, options = list(rows.print = 15))
```


## Enrichment analysis

```{r, enrichgo-cc}
# Your existing code for obtaining geneList with Ensembl IDs
rownames(res_aff_vs_unaff_df_sub) <- gsub("\\..*", "", rownames(res_aff_vs_unaff_df_sub))
res_aff_vs_unaff_df_sub <- res_aff_vs_unaff_df_sub %>% dplyr::distinct()
geneList <- res_aff_vs_unaff_df_sub$log2FoldChange
geneList2 <- res_aff_vs_unaff_df_sub$padj
geneList3 <- res_aff_vs_unaff_df_sub$padj
names(geneList3) <- rownames(res_aff_vs_unaff_df_sub)
names(geneList2) <- rownames(res_aff_vs_unaff_df_sub)
names(geneList) <- rownames(res_aff_vs_unaff_df_sub)

# Initialize BioMart
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

# Convert all Ensembl IDs in geneList to Entrez IDs
attributes <- c("ensembl_gene_id", "entrezgene_id")
filters <- "ensembl_gene_id"
results <- getBM(attributes = attributes, filters = filters, values = names(geneList), mart = ensembl)
results3 <- getBM(attributes = attributes, filters = filters, values = names(geneList2), mart = ensembl)

# Convert all Ensembl IDs in geneList to Entrez IDs
# This is for genes of interest
attributes2 <- c("hgnc_symbol", "ensembl_gene_id", "entrezgene_id")
filters2 <- "hgnc_symbol"
results2 <- getBM(attributes = attributes2, filters = filters2, values = genes_of_interest, mart = ensembl)

# Remove rows with NA or empty Entrez IDs
results <- results[!is.na(results$entrezgene_id) & results$entrezgene_id != "", ]
results3 <- results3[!is.na(results3$entrezgene_id) & results3$entrezgene_id != "", ]

results2 <- results2[!is.na(results2$entrezgene_id) & results2$entrezgene_id != "", ]

# Create a new geneList with Entrez IDs
geneList_entrez <- geneList[results$ensembl_gene_id]
names(geneList_entrez) <- results$entrezgene_id

# Create a new geneList with Entrez IDs
geneList_entrez2 <- geneList2[results3$ensembl_gene_id]
names(geneList_entrez2) <- results3$entrezgene_id

# Create a new geneList with Entrez IDs
geneList_entrez3 <- geneList3[results2$ensembl_gene_id]
names(geneList_entrez3) <- results2$entrezgene_id

# Filter genes with abs(log2FoldChange) > 2
gene_entrez <- names(geneList_entrez)[abs(geneList_entrez) > 2]

# Filter genes with padj < .05
gene_entrez2 <- names(geneList_entrez2)[!is.na(geneList_entrez2) & geneList_entrez2 < .05]

# Run enrichGO with Entrez IDs
ego_cc <- enrichGO(
  gene = gene_entrez,
  universe = names(geneList_entrez),
  OrgDb = org.Hs.eg.db,
  ont = "CC",
  pAdjustMethod = "BH",
  pvalueCutoff = 0.01,
  qvalueCutoff = 0.05,
  readable = TRUE
)

# Plot results
dotplot(ego_cc, showCategory = 10, title = "Overrepresented Cellular Components") + ggthemes::theme_clean()
```

```{r, enrichgo-mf}
ego_mf <- enrichGO(
  gene = gene_entrez,
  universe = names(geneList_entrez),
  OrgDb = org.Hs.eg.db,
  ont = "MF",
  pAdjustMethod = "BH",
  pvalueCutoff = 0.01,
  qvalueCutoff = 0.05,
  readable = TRUE
)

# Plot results
dotplot(ego_mf, showCategory = 10, title = "Overrepresented Molecular Functions") + ggthemes::theme_clean()
```


```{r, dose-plot}
gl <- geneList_entrez[abs(geneList_entrez) > 2]
gl <- na.omit(gl)
gl_sorted <- sort(gl, decreasing = TRUE)

gse <- gseGO(
  geneList = gl_sorted,
  OrgDb = org.Hs.eg.db,
  ont = "ALL",
  minGSSize = 3,
  maxGSSize = 500,
  pvalueCutoff = 0.05,
  verbose = FALSE
)

dotplot(gse, showCategory = 10, split = ".sign", title = "GO Gene Set Enrichment Analysis") + facet_grid(. ~ .sign)
```


```{r, kegg-plot}
kk2 <- gseKEGG(
  geneList = gl_sorted,
  organism = "hsa", # humans = hsa for KEGG
  nPerm = 100000,
  minGSSize = 3,
  maxGSSize = 800,
  pvalueCutoff = 0.05,
  pAdjustMethod = "none",
  keyType = "ncbi-geneid"
)

dotplot(kk2, showCategory = 10, title = "Enriched KEGG Pathways", split = ".sign") + facet_grid(. ~ .sign)
```

```{r, reactome-plot}
y <- enrichPathway(gene_entrez, pvalueCutoff = 0.05)

dotplot(y, showCategory = 10, title = "Reactome Pathway Over-representation Analysis", font.size = 10)
```


```{r, stringdb-network-significant}
string_db <- STRINGdb$new(version = "11.5", species = 9606, score_threshold = 100, network_type = "full", input_directory = "")

mapped_degs <- string_db$map(significant_data, "name", removeUnmappedRows = TRUE)
hits <- mapped_degs$STRING_id[1:29]

mapped_degs_dec <- string_db$add_diff_exp_color(mapped_degs, logFcColStr = "lfc")

payload_id <- string_db$post_payload(mapped_degs_dec$STRING_id, colors = mapped_degs_dec$color)
string_db$plot_network(hits, payload_id = payload_id)
```

## Genes of Interest Plot Counts

```{r, generate-plot-counts-genes-interest-subsetted}
# List of gene names to remove or keep
genes_to_filter <- c("AHSP", "HEMGN", "SLC4A1", "KEL", "SPTA1", "RHAG", 
                     "GYPE", "GYPA", "GYPB", "EPB42", "SPTB", "SPTBN5")

# Define paths
output_path <- "output/publication-analysis/batch-correction-limma/plot-counts/genes-of-interest"

# Filter genes
filtered_without_genes <- filter_genes(filtered_by_interest, genes_to_filter, include = FALSE)

# Generate plots and results using the modularized functions
results <- process_genes_of_interest(
  filtered_data = filtered_by_interest,
  dds = dds,
  vsd = vsd_limma,
  genes_to_filter = genes_to_filter,
  output_path = output_path
)

# Extract the faceted plot and gene results
faceted_plot <- results$faceted_plot
gene_results_df <- results$gene_results_df

# Save the gene results to a CSV
file_name <- file.path(output_path, "genes_of_interest_plot_counts_signals.csv")
write.csv(gene_results_df, file_name, row.names = FALSE)

# Prepare the heatmap data
mat3 <- assay(vsd_limma)[filtered_without_genes$Ensembl_ID, ]
rownames(mat3) <- gene_info$gene_name[match(filtered_without_genes$Ensembl_ID, gene_info$Ensembl_ID)]
df_sub <- as.data.frame(colData(vsd_limma)[, c("Affected", "OverallCategory")])

# Create the heatmap
create_heatmap(
  mat = mat3,
  gene_info = gene_info,
  vsd_coldata = colData(vsd_limma),
  output_path = output_path,
  ann_colors = ann_colors,
  clusters = 3
)
```


## Additional Interesting Genes

```{r, generate-plot-counts-genes-interest-subsetted}
# Create an empty list to store the results for each gene
gene_results_list <- list()

# Create an empty dataframe to store all counts data for plotting
gi_all_counts <- data.frame()

# Loop through each gene to calculate and plot counts
for (ensembl_id in filtered_with_only_genes$Ensembl_ID) {
  d <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  dp <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  gene_name <- filtered_with_only_genes$gene_name[filtered_with_only_genes$Ensembl_ID == ensembl_id]
  
  # Calculate the mean and standard deviation of counts within each condition
  d_stats <- d %>%
    group_by(Affected) %>%
    summarise(
      mean_count = mean(count),
      sd_count = sd(count)
    )
  
  # Merge statistics back with the data
  d <- merge(d, d_stats, by = "Affected")
  
  # Create a temporary dataframe to store results for this gene
  temp_gene_df <- data.frame(
    Patient = rownames(d),
    stringsAsFactors = FALSE
  )
  
  # Calculate Z-scores and determine regulation status
  regulation_status <- sapply(1:nrow(d), function(i) {
    z_score <- (d$count[i] - d$mean_count[i]) / d$sd_count[i]
    
    # Determine regulation status based on Z-score
    if (z_score > 1) {
      return("Upregulated")
    } else if (z_score < -1) {
      return("Downregulated")
    } else {
      return("Neutral")
    }
  })
  
  # Add the regulation status to the temporary dataframe
  temp_gene_df[[gene_name]] <- regulation_status
  
  # Merge the temporary dataframe with the results list
  if (length(gene_results_list) == 0) {
    gene_results_list[[1]] <- temp_gene_df
  } else {
    gene_results_list[[1]] <- merge(gene_results_list[[1]], temp_gene_df, by = "Patient", all = TRUE)
  }
  
  # Add the gene name to the dp dataframe
  dp$Gene <- gene_name
  dp$Ensembl_ID <- ensembl_id
  dp$SampleID <- rownames(dp)
  
  # Combine dp with all_counts dataframe
  gi_all_counts <- rbind(gi_all_counts, dp)
  
  # Generate the boxplot
  gene_plot <- ggboxplot(dp,
    x = "Affected", y = "count", add = "jitter",
    color = "Affected", palette = c("red", "navy"),
    title = gene_name
  ) +
    geom_text_repel(aes(label = rownames(dp))) +
    scale_color_manual(
      name = "Affected Status",
      labels = c("Affected", "Unaffected"),
      values = c("red", "navy")
    )
  print(gene_plot) # Ensure each plot is printed during the loop
  ggsave(
    filename = paste0(gene_name, "-subsetted-plot-counts.png"),
    path = "output/publication-analysis/batch-correction-limma/plot-counts/additional-genes-of-interest",
    plot = gene_plot, dpi = 450
  )
}

# Create the faceted plot
faceted_plot <- ggplot(gi_all_counts, aes(x = Affected, y = count, color = Affected)) +
  geom_boxplot(alpha = 0.35) +
  geom_jitter(width = 0.2, size = .45) + # Adjust size of the dots
  geom_text_repel(aes(label = SampleID), size = 2, 
                  max.overlaps = Inf, force = 10, color = "black",
                  segment.color = "gray",
                  min.segment.length = 0,
                  point.padding = 0.1
                  ) + # Add labels to the dots
  facet_wrap(~ Gene, scales = "free_y") +
  theme_bw() +
  labs(title = "Gene Expression Counts by Affected Status", x = "Affected Status", y = "Count") +
  scale_color_manual(values = c("red", "navy")) +
  theme(
    legend.position = "bottom",
    plot.margin = margin(10, 10, 10, 10),
    strip.text = element_text(size = 6),  # Adjust facet label text size
    plot.title = element_text(size = 10),
    axis.title = element_text(size = 10),
    axis.text = element_text(size = 6),
    panel.spacing = unit(.35, "lines")  # Add space between facets
  ) +
  coord_cartesian(clip = "off")  # Ensure labels are not clipped
 

faceted_plot

# Save the faceted plot
ggsave(
  filename = "faceted_additional_genes_of_interest_plot_counts.png",
  path = "output/publication-analysis/batch-correction-limma/plot-counts/additional-genes-of-interest",
  plot = faceted_plot, dpi = 2200
)

# Convert the list to a dataframe
gene_results_df <- gene_results_list[[1]]

file_name <- "output/publication-analysis/genes_of_interest_plot_counts_signals.csv"
write.csv(gene_results_df, file_name, row.names = FALSE)
```

Below is a heatmap highlighting the expression of our genes of interest across batch, disease group, and affected status.

```{r, heatmap-additional-genes-interest-subsetted, out.width = "1200px"}
# Prepare data for the heatmap
mat4 <- assay(vsd_limma)[filtered_with_only_genes$Ensembl_ID, ]
rownames(mat4) <- gene_info$gene_name[match(filtered_with_only_genes$Ensembl_ID, gene_info$Ensembl_ID)]
df_sub <- as.data.frame(colData(vsd_limma)[, c("Affected", "OverallCategory")])

# Set up color palette
color_palette <- colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(50)

# Specify the number of row clusters
num_row_clusters <- 3

png("output/publication-analysis/additional_genes_of_interest_heatmap.png", width = 12, height = 10, units = "in", res = 1200)

draw(ComplexHeatmap::pheatmap(
    mat = mat4,
    color = colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(50),
    annotation_col = df_sub,
    annotation_colors = ann_colors,
    fontsize = 6,
    angle_col = c("0"),
    cellheight = 10,  # Set cell height
    cellwidth = 24,   # Set cell width
    border_color = "black",  # Black borders around heatmap cells
    #cutree_rows = num_row_clusters,  # Number of row clusters
    heatmap_legend_param = list(
        title = "Matrix"
    )
))

dev.off()
```


## Significant Genes Plot Counts

```{r, generate-plot-counts-genes-significant}
# Create an empty list to store the results for each gene
results_list <- list()

# Create an empty dataframe to store all counts data for plotting
all_counts <- data.frame()

# Loop through each gene to calculate and plot counts
for (ensembl_id in res_aff_vs_unaff_df_genename_padj05_lfc1$Ensembl_ID) {
  dp <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  d <- plotCounts(dds, gene = ensembl_id, intgroup = "Affected", returnData = TRUE)
  gene_name <- res_aff_vs_unaff_df_genename_padj05_lfc1$gene_name[res_aff_vs_unaff_df_genename_padj05_lfc1$Ensembl_ID == ensembl_id]
  
  # Calculate the mean and standard deviation of counts within each condition
  d_stats <- d %>%
    group_by(Affected) %>%
    summarise(
      mean_count = mean(count),
      sd_count = sd(count)
    )
  
  # Merge statistics back with the data
  d <- merge(d, d_stats, by = "Affected")
  
  # Create a temporary dataframe to store results for this gene
  temp_df <- data.frame(
    Patient = rownames(d),
    stringsAsFactors = FALSE
  )
  
  # Calculate Z-scores and determine regulation status
  regulation_status <- sapply(1:nrow(d), function(i) {
    if (is.na(d$sd_count[i]) || d$sd_count[i] == 0) {
      return("Neutral")
    }
    
    z_score <- (d$count[i] - d$mean_count[i]) / d$sd_count[i]
    
    # Determine regulation status based on Z-score
    if (is.na(z_score)) {
      return("Neutral")
    } else if (z_score > 1) {
      return("Upregulated")
    } else if (z_score < -1) {
      return("Downregulated")
    } else {
      return("Neutral")
    }
  })
  
  # Add the regulation status to the temporary dataframe
  temp_df[[gene_name]] <- regulation_status
  
  # Merge the temporary dataframe with the results list
  if (length(results_list) == 0) {
    results_list[[1]] <- temp_df
  } else {
    results_list[[1]] <- merge(results_list[[1]], temp_df, by = "Patient", all = TRUE)
  }
  
  # Add the gene name to the dp dataframe
  dp$Gene <- gene_name
  dp$Ensembl_ID <- ensembl_id
  dp$SampleID <- rownames(dp)
  
  # Combine dp with all_counts dataframe
  all_counts <- rbind(all_counts, dp)
  
  # Generate the boxplot
  ggplot_box <- ggboxplot(dp,
    x = "Affected", y = "count", add = "jitter",
    color = "Affected", palette = c("red", "navy"),
    title = gene_name
  ) +
    geom_text_repel(aes(label = rownames(dp))) +
    scale_color_manual(
      name = "Affected Status",
      labels = c("Affected", "Unaffected"),
      values = c("red", "navy")
    )
  print(ggplot_box) # Ensure each plot is printed during the loop
  ggsave(
    filename = paste0(gene_name, "-subsetted-plot-counts.png"),
    path = "output/publication-analysis/batch-correction-limma/plot-counts/padj-05",
    plot = ggplot_box, dpi = 450
  )
}

# Create the faceted plot
faceted_plot <- ggplot(all_counts, aes(x = Affected, y = count, color = Affected)) +
  geom_boxplot(alpha = 0.4) +
  geom_jitter(width = 0.2, size = 1.25) + # Adjust size of the dots
  geom_text_repel(aes(label = SampleID), size = 2, 
                  max.overlaps = Inf, force = 10, color = "black",
                  segment.color = "gray",
                  min.segment.length = 0,
                  point.padding = 0.1
                  ) + # Add labels to the dots
  facet_wrap(~ Gene, scales = "free_y") +
  theme_bw() +
  labs(title = "Gene Expression Counts by Affected Status", x = "Affected Status", y = "Count") +
  scale_color_manual(values = c("red", "navy")) +
  theme(
    legend.position = "bottom",
    plot.margin = margin(10, 10, 10, 10),
    strip.text = element_text(size = 8),  # Adjust facet label text size
    plot.title = element_text(size = 14),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    panel.spacing = unit(1, "lines")  # Add space between facets
  ) +
  coord_cartesian(clip = "off")  # Ensure labels are not clipped
 

faceted_plot

# Save the faceted plot
ggsave(
  filename = "faceted_significant_degs_plot_counts.png",
  path = "output/publication-analysis/batch-correction-limma/plot-counts/padj-05",
  plot = faceted_plot, dpi = 1200
)

# Convert the list to a dataframe
results_df <- results_list[[1]]

file_name <- "output/publication-analysis/significant_plot_counts_signals.csv"
write.csv(results_df, file_name, row.names = FALSE)
```

### Save data

```{r, save-data}
save.image(file = "output/publication-analysis/subsetted-condition-analysis.RData")
```

